import express from 'express';
import jwt from 'jsonwebtoken';
import { request } from 'undici';
import fs from 'fs';
import YAML from 'yaml';
import crypto from 'crypto';
import { createClient } from 'redis';

export class OpenIdRouter {
    constructor(appPath) {
        this.appPath = appPath;
        this.router = express.Router();
        this.config = {};
        this.redisClient = null;
        
        // Load config
        try {
            this.config = YAML.parse(fs.readFileSync(this.appPath + '/config/local.yaml', 'utf-8'));
            
            // Validate required config exists
            if (!this.config.oauth) {
                throw new Error('OAuth configuration missing from local.yaml');
            }
            if (!this.config.oauth.client_id) {
                throw new Error('oauth.client_id missing from local.yaml');
            }
            if (!this.config.oauth.client_secret) {
                throw new Error('oauth.client_secret missing from local.yaml');
            }
            if (!this.config.oauth.session_secret) {
                throw new Error('oauth.session_secret missing from local.yaml');
            }
            if (!this.config.oauth.scope) {
                throw new Error('oauth.scope missing from local.yaml');
            }
            if (!this.config.cors) {
                throw new Error('cors configuration missing from local.yaml');
            }
            if (!this.config.cors.allowed_origins) {
                throw new Error('cors.allowed_origins missing from local.yaml');
            }
            if (!this.config.redis) {
                throw new Error('redis configuration missing from local.yaml');
            }
            if (!this.config.redis.host) {
                throw new Error('redis.host missing from local.yaml');
            }
            if (!this.config.redis.port) {
                throw new Error('redis.port missing from local.yaml');
            }
            
        } catch (error) {
            console.error('Error: Could not load OpenID Connect configuration:', error.message);
            throw new Error('OpenID Connect service requires proper configuration in local.yaml');
        }
        
        this.setupMiddleware();
        this.setupRoutes();
    }
    
    // Template loading and rendering utilities
    loadTemplate(templateName) {
        return fs.readFileSync(`${this.appPath}/templates/${templateName}.html`, 'utf-8');
    }
    
    renderTemplate(template, replacements) {
        return Object.entries(replacements).reduce(
            (html, [key, val]) => html.replace(new RegExp(`{{${key}}}`, 'g'), val),
            template
        );
    }
    
    async initialize() {
        // Initialize Redis connection
        await this.initializeRedis();
        
        console.log('OpenID Connect Router initialized');
        console.log('- OpenID Connect middleware ready');
        console.log('- Static file serving ready');
        console.log('- Redis session storage ready');
    }
    
    async initializeRedis() {
        try {
            this.redisClient = createClient({
                socket: {
                    host: this.config.redis.host,
                    port: this.config.redis.port
                }
            });
            
            this.redisClient.on('error', (err) => {
                console.error('Redis connection error:', err);
            });
            
            this.redisClient.on('connect', () => {
                console.log(`Connected to Redis at ${this.config.redis.host}:${this.config.redis.port}`);
            });
            
            await this.redisClient.connect();
            console.log('Redis client connected successfully');
            
        } catch (error) {
            console.error('Failed to connect to Redis:', error);
            console.log('Falling back to in-memory session storage');
            this.redisClient = null;
            this.sessions = new Map(); // Fallback to in-memory
        }
    }
    
    // Redis session management methods
    async setSession(sessionId, sessionData, ttlSeconds = 3600) {
        try {
            if (this.redisClient) {
                const sessionKey = `session:${sessionId}`;
                await this.redisClient.setEx(sessionKey, ttlSeconds, JSON.stringify(sessionData));
                console.log(`[REDIS] Session ${sessionId} stored with TTL ${ttlSeconds}s`);
            } else {
                // Fallback to in-memory
                this.sessions.set(sessionId, {
                    ...sessionData,
                    expires: Date.now() + (ttlSeconds * 1000)
                });
                console.log(`[MEMORY] Session ${sessionId} stored with TTL ${ttlSeconds}s`);
            }
        } catch (error) {
            console.error('Error setting session:', error);
            // Fallback to in-memory on Redis error
            this.sessions.set(sessionId, {
                ...sessionData,
                expires: Date.now() + (ttlSeconds * 1000)
            });
        }
    }
    
    async getSession(sessionId) {
        try {
            if (this.redisClient) {
                const sessionKey = `session:${sessionId}`;
                const sessionData = await this.redisClient.get(sessionKey);
                if (sessionData) {
                    console.log(`[REDIS] Session ${sessionId} retrieved`);
                    return JSON.parse(sessionData);
                }
                console.log(`[REDIS] Session ${sessionId} not found`);
                return null;
            } else {
                // Fallback to in-memory
                const session = this.sessions.get(sessionId);
                if (session && session.expires > Date.now()) {
                    console.log(`[MEMORY] Session ${sessionId} retrieved`);
                    return session;
                } else if (session) {
                    this.sessions.delete(sessionId); // Clean up expired session
                    console.log(`[MEMORY] Session ${sessionId} expired and removed`);
                }
                return null;
            }
        } catch (error) {
            console.error('Error getting session:', error);
            // Fallback to in-memory on Redis error
            const session = this.sessions.get(sessionId);
            return (session && session.expires > Date.now()) ? session : null;
        }
    }
    
    async deleteSession(sessionId) {
        try {
            if (this.redisClient) {
                const sessionKey = `session:${sessionId}`;
                await this.redisClient.del(sessionKey);
                console.log(`[REDIS] Session ${sessionId} deleted`);
            } else {
                // Fallback to in-memory
                this.sessions.delete(sessionId);
                console.log(`[MEMORY] Session ${sessionId} deleted`);
            }
        } catch (error) {
            console.error('Error deleting session:', error);
            // Fallback to in-memory on Redis error
            this.sessions.delete(sessionId);
        }
    }
    
    setupMiddleware() {
        // Enhanced CORS middleware (replacing APISIX CORS)
        this.router.use((req, res, next) => {
            const origin = req.headers.origin;
            const allowedOrigins = this.config.cors?.allowed_origins || [];
            
            if (allowedOrigins.includes(origin)) {
                res.setHeader('Access-Control-Allow-Origin', origin);
            }
            
            res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
            res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Access-Token, X-ID-Token, X-Userinfo, Mcp-Session-Id');
            res.setHeader('Access-Control-Allow-Credentials', 'true');
            
            if (req.method === 'OPTIONS') {
                return res.sendStatus(200);
            }
            next();
        });
        
        // Static file serving (replacing nginx on port 9280)
        this.router.use('/static', express.static('templates'));
        this.router.use('/static', express.static('public'));
        
        // Parse cookies for session management
        this.router.use((req, res, next) => {
            req.cookies = {};
            if (req.headers.cookie) {
                req.headers.cookie.split(';').forEach(cookie => {
                    const [name, value] = cookie.trim().split('=');
                    req.cookies[name] = decodeURIComponent(value);
                });
            }
            next();
        });
    }
    
    // OpenID Connect middleware (replacing APISIX openid-connect plugin)
    createOpenIDConnectMiddleware() {
        return async (req, res, next) => {
            try {
                console.log(`[OIDC] Processing request: ${req.method} ${req.path}`);
                
                // Skip authentication for specific paths
                const skipPaths = ['/health', '/login', '/consent', '/oauth', '/.well-known'];
                if (skipPaths.some(path => req.path.startsWith(path))) {
                    return next();
                }
                
                // Check for existing session
                const sessionId = req.cookies['mcp-session'] || req.headers['mcp-session-id'];
                if (sessionId) {
                    const session = await this.getSession(sessionId);
                    
                    if (session) {
                        // Add user info to request
                        req.user = session.user;
                        req.accessToken = session.accessToken;
                        req.idToken = session.idToken;
                        
                        // Set headers as APISIX did
                        res.setHeader('X-Access-Token', session.accessToken);
                        res.setHeader('X-ID-Token', session.idToken);
                        if (session.userinfo) {
                            res.setHeader('X-Userinfo', JSON.stringify(session.userinfo));
                        }
                        
                        console.log(`[OIDC] Valid session found for user: ${session.user.sub}`);
                        return next();
                    }
                }
                
                // Check for Bearer token in Authorization header
                const authHeader = req.headers.authorization;
                if (authHeader && authHeader.startsWith('Bearer ')) {
                    const token = authHeader.substring(7);
                    
                    try {
                        // Introspect token with Hydra
                        const introspectResult = await this.introspectToken(token);
                        if (introspectResult.active) {
                            // Token is valid, create temporary session
                            const userinfo = await this.getUserInfo(token);
                            
                            req.user = { sub: introspectResult.sub };
                            req.accessToken = token;
                            
                            // Set headers
                            res.setHeader('X-Access-Token', token);
                            if (userinfo) {
                                res.setHeader('X-Userinfo', JSON.stringify(userinfo));
                            }
                            
                            console.log(`[OIDC] Valid Bearer token for user: ${introspectResult.sub}`);
                            return next();
                        }
                    } catch (tokenError) {
                        console.log(`[OIDC] Token validation failed: ${tokenError.message}`);
                    }
                }
                
                // No valid authentication found, redirect to OAuth flow
                console.log(`[OIDC] No valid authentication, redirecting to OAuth`);
                await this.initiateOAuthFlow(req, res);
                
            } catch (error) {
                console.error(`[OIDC] Middleware error: ${error.message}`);
                res.status(500).json({ error: 'Authentication error' });
            }
        };
    }
    
    // Initiate OAuth flow (similar to APISIX openid-connect)
    async initiateOAuthFlow(req, res) {
        const state = crypto.randomBytes(16).toString('hex');
        const redirectUri = `${this.config.hydra?.public_url || 'http://localhost:3000'}/oauth/callback`;
        
        // Store state for validation (5 minutes TTL)
        await this.setSession(`state:${state}`, {
            originalUrl: req.originalUrl
        }, 300);
        
        const authParams = new URLSearchParams({
            client_id: this.config.oauth.client_id,
            response_type: 'code',
            scope: this.config.oauth.scope,
            redirect_uri: redirectUri,
            state: state
        });
        
        const authUrl = `${this.config.hydra.public_url}/oauth/oauth2/auth?${authParams.toString()}`;
        
        console.log(`[OIDC] Redirecting to OAuth: ${authUrl}`);
        res.redirect(authUrl);
    }
    
    // Token introspection
    async introspectToken(token) {
        try {
            const response = await request(`http://${this.config.hydra.hostname}:${this.config.hydra.admin_port}/admin/oauth2/introspect`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': `Basic ${Buffer.from(`${this.config.oauth.client_id}:${this.config.oauth.client_secret}`).toString('base64')}`
                },
                body: new URLSearchParams({ token }).toString()
            });
            
            if (response.statusCode === 200) {
                return await response.body.json();
            }
            
            throw new Error(`Introspection failed: ${response.statusCode}`);
        } catch (error) {
            console.error('Token introspection error:', error);
            return { active: false };
        }
    }
    
    // Get user info
    async getUserInfo(token) {
        try {
            const response = await request(`${this.config.hydra.public_url}/oauth/userinfo`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (response.statusCode === 200) {
                return await response.body.json();
            }
            
            return null;
        } catch (error) {
            console.error('UserInfo error:', error);
            return null;
        }
    }
    
    setupRoutes() {
        // OAuth callback handler (replaces APISIX flow)
        this.router.get('/oauth/callback', async (req, res) => {
            try {
                const { code, state, error } = req.query;
                
                if (error) {
                    return res.status(400).json({ error: 'OAuth error', details: error });
                }
                
                if (!code || !state) {
                    return res.status(400).json({ error: 'Missing code or state parameter' });
                }
                
                // Validate state
                const stateData = await this.getSession(`state:${state}`);
                if (!stateData) {
                    console.error(`[OIDC] Invalid state parameter: ${state}`);
                    return res.status(400).json({ error: 'Invalid state parameter' });
                }
                
                // Clean up state immediately to prevent reuse
                await this.deleteSession(`state:${state}`);
                
                // Exchange code for tokens
                const tokenResponse = await this.exchangeCodeForTokens(code);
                if (!tokenResponse) {
                    return res.status(500).json({ error: 'Failed to exchange code for tokens' });
                }
                
                // Get user info
                const userinfo = await this.getUserInfo(tokenResponse.access_token);
                
                // Create session
                const sessionId = crypto.randomBytes(32).toString('hex');
                const sessionTTL = tokenResponse.expires_in || 3600;
                await this.setSession(sessionId, {
                    user: { sub: userinfo?.sub || 'unknown' },
                    accessToken: tokenResponse.access_token,
                    idToken: tokenResponse.id_token,
                    refreshToken: tokenResponse.refresh_token,
                    userinfo: userinfo
                }, sessionTTL);
                
                // Set session cookie
                res.cookie('mcp-session', sessionId, {
                    httpOnly: true,
                    secure: req.secure,
                    maxAge: tokenResponse.expires_in * 1000
                });
                
                console.log(`[OIDC] OAuth callback successful, redirecting to: ${stateData.originalUrl}`);
                res.redirect(stateData.originalUrl || '/');
                
            } catch (error) {
                console.error('OAuth callback error:', error);
                res.status(500).json({ error: 'OAuth callback failed' });
            }
        });
        
        // Logout endpoint
        this.router.post('/logout', async (req, res) => {
            const sessionId = req.cookies['mcp-session'];
            if (sessionId) {
                await this.deleteSession(sessionId);
                res.clearCookie('mcp-session');
            }
            res.json({ message: 'Logged out successfully' });
        });
        
        // Well-known endpoints (consolidated from APISIX routes)
        this.router.get('/.well-known/oauth-authorization-server', async (req, res) => {
            try {
                const response = await request(`${this.config.hydra.public_url}/oauth/.well-known/openid-configuration`);
                const body = await response.body.text();
                res.setHeader('Content-Type', 'application/json');
                res.send(body);
            } catch (error) {
                console.error('Well-known endpoint error:', error);
                res.status(500).json({ error: 'Failed to fetch configuration' });
            }
        });
        
        // Note: OpenID Connect configuration endpoint is handled by OAuth proxy service at /oauth/.well-known/openid-configuration
        
        // API docs route - Dynamic generation
        this.router.get('/docs', (req, res) => {
            const apiDocs = this.generateApiDocumentation();
            res.setHeader('Content-Type', 'text/html');
            res.send(apiDocs);
        });
        
        // Legacy route for backward compatibility
        this.router.get('/oauth/api-docs.html', (req, res) => {
            const apiDocs = this.generateApiDocumentation();
            res.setHeader('Content-Type', 'text/html');
            res.send(apiDocs);
        });
        
        // OAuth protected resource discovery - Dynamic generation
        this.router.get('/.well-known/oauth-protected-resource', (req, res) => {
            const discoveryDoc = this.generateOAuthProtectedResourceDiscovery();
            res.setHeader('Content-Type', 'application/json');
            res.json(discoveryDoc);
        });
        
        this.router.get('/.well-known/oauth-protected-resource/mcp/*', (req, res) => {
            const mcpDoc = this.generateOAuthProtectedResourceMcp();
            res.setHeader('Content-Type', 'application/json');
            res.json(mcpDoc);
        });
        
        // Legacy routes for backward compatibility
        this.router.get('/oauth/oauth-protected-resource-discovery.json', (req, res) => {
            const discoveryDoc = this.generateOAuthProtectedResourceDiscovery();
            res.setHeader('Content-Type', 'application/json');
            res.json(discoveryDoc);
        });
        
        this.router.get('/oauth/oauth-protected-resource-mcp.json', (req, res) => {
            const mcpDoc = this.generateOAuthProtectedResourceMcp();
            res.setHeader('Content-Type', 'application/json');
            res.json(mcpDoc);
        });
    }
    
    // Exchange authorization code for tokens
    async exchangeCodeForTokens(code) {
        try {
            const redirectUri = `${this.config.hydra?.public_url || 'http://localhost:3000'}/oauth/callback`;
            console.log(`[OIDC] Token exchange - redirect_uri: ${redirectUri}`);
            
            const tokenUrl = `http://${this.config.hydra.hostname}:${this.config.hydra.public_port}/oauth2/token`;
            const tokenPayload = {
                grant_type: 'authorization_code',
                code: code,
                redirect_uri: redirectUri
            };
            
            console.log(`[OIDC] Token exchange request to: ${tokenUrl}`);
            console.log(`[OIDC] Token exchange payload:`, tokenPayload);
            
            const response = await request(tokenUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': `Basic ${Buffer.from(`${this.config.oauth.client_id}:${this.config.oauth.client_secret}`).toString('base64')}`
                },
                body: new URLSearchParams(tokenPayload).toString()
            });
            
            if (response.statusCode === 200) {
                const tokenData = await response.body.json();
                console.log(`[OIDC] Token exchange successful`);
                return tokenData;
            }
            
            const errorBody = await response.body.text();
            console.error(`[OIDC] Token exchange failed: ${response.statusCode} - ${errorBody}`);
            return null;
        } catch (error) {
            console.error('Token exchange error:', error);
            return null;
        }
    }
    
    // Generate OAuth Protected Resource Discovery document dynamically
    generateOAuthProtectedResourceDiscovery() {
        const baseUrl = this.config.hydra?.public_url || `http://localhost:${this.config.server_port || 3000}`;
        
        return {
            "issuer": `${baseUrl}/oauth`,
            "authorization_endpoint": `${baseUrl}/oauth/oauth2/auth`,
            "token_endpoint": `${baseUrl}/oauth/oauth2/token`,
            "userinfo_endpoint": `${baseUrl}/oauth/userinfo`,
            "revocation_endpoint": `${baseUrl}/oauth/oauth2/revoke`,
            "introspection_endpoint": `${baseUrl}/oauth/admin/oauth2/introspect`,
            "jwks_uri": `${baseUrl}/oauth/.well-known/jwks.json`,
            "response_types_supported": [
                "code",
                "id_token",
                "token id_token",
                "code id_token",
                "code token",
                "code token id_token"
            ],
            "subject_types_supported": [
                "public"
            ],
            "id_token_signing_alg_values_supported": [
                "RS256"
            ],
            "scopes_supported": this.config.oauth?.allowed_scopes || [
                "openid",
                "profile",
                "email",
                "offline_access",
                "mcp:read"
            ],
            "token_endpoint_auth_methods_supported": [
                "client_secret_basic",
                "client_secret_post"
            ],
            "claims_supported": [
                "sub",
                "aud",
                "exp",
                "iat",
                "iss",
                "auth_time",
                "nonce",
                "email",
                "email_verified",
                "name",
                "given_name",
                "family_name",
                "picture"
            ],
            "code_challenge_methods_supported": [
                "S256",
                "plain"
            ],
            "grant_types_supported": [
                "authorization_code",
                "implicit",
                "refresh_token"
            ]
        };
    }
    
    // Generate OAuth Protected Resource MCP document dynamically
    generateOAuthProtectedResourceMcp() {
        const baseUrl = this.config.hydra?.public_url || `http://localhost:${this.config.server_port || 3000}`;
        
        return {
            "resource_server": {
                "resource_server_id": "mcp-launcher",
                "resource_server_name": "MCP Launcher Service",
                "resource_server_uri": `${baseUrl}/mcp`,
                "resource_server_icon_uri": `${baseUrl}/static/mcp-icon.png`
            },
            "authorization_server": {
                "issuer": `${baseUrl}/oauth`,
                "authorization_endpoint": `${baseUrl}/oauth/oauth2/auth`,
                "token_endpoint": `${baseUrl}/oauth/oauth2/token`,
                "userinfo_endpoint": `${baseUrl}/oauth/userinfo`,
                "jwks_uri": `${baseUrl}/oauth/.well-known/jwks.json`,
                "introspection_endpoint": `${baseUrl}/oauth/admin/oauth2/introspect`
            },
            "scopes_supported": this.config.oauth?.allowed_scopes || [
                "openid",
                "profile", 
                "email",
                "mcp:read"
            ],
            "resource_scopes": [
                {
                    "scope": "mcp:read",
                    "description": "Read access to MCP (Model Context Protocol) services",
                    "resources": [
                        `${baseUrl}/mcp/message`,
                        `${baseUrl}/mcp/tools`,
                        `${baseUrl}/mcp/resources`
                    ]
                }
            ],
            "endpoints": [
                {
                    "endpoint": `${baseUrl}/mcp/message`,
                    "method": "POST",
                    "scopes_required": ["mcp:read"],
                    "description": "Send messages to MCP services"
                },
                {
                    "endpoint": `${baseUrl}/mcp/tools`,
                    "method": "GET", 
                    "scopes_required": ["mcp:read"],
                    "description": "List available MCP tools"
                },
                {
                    "endpoint": `${baseUrl}/mcp/resources`,
                    "method": "GET",
                    "scopes_required": ["mcp:read"], 
                    "description": "List available MCP resources"
                }
            ],
            "token_introspection_endpoint": `${baseUrl}/oauth/admin/oauth2/introspect`,
            "token_introspection_endpoint_auth_methods_supported": [
                "client_secret_basic",
                "client_secret_post"
            ]
        };
    }
    
    // Generate API documentation dynamically from template
    generateApiDocumentation() {
        const baseUrl = this.config.hydra?.public_url || `http://localhost:${this.config.server_port || 3000}`;
        const serviceName = 'MCP Launcher OAuth Proxy';
        
        try {
            const template = this.loadTemplate('api-docs');
            return this.renderTemplate(template, {
                SERVICE_NAME: serviceName,
                BASE_URL: baseUrl,
                CLIENT_ID: this.config.oauth?.client_id || 'Not configured',
                SUPPORTED_SCOPES: (this.config.oauth?.allowed_scopes || []).join(', '),
                ALLOWED_DOMAINS: (this.config.oauth?.allowed_redirect_domains || []).join(', '),
                CORS_ORIGINS: (this.config.cors?.allowed_origins || []).join(', ')
            });
        } catch (error) {
            console.error('Error loading API docs template:', error);
            return '<html><body><h1>Error loading API documentation</h1><p>Template not found</p></body></html>';
        }
    }
    
    // Get OpenID Connect middleware for protected routes
    getOpenIDConnectMiddleware() {
        return this.createOpenIDConnectMiddleware();
    }
    
    getRouter() {
        return this.router;
    }
    
    async shutdown() {
        console.log('OpenID Connect Router shutting down...');
        
        // Close Redis connection
        if (this.redisClient) {
            try {
                await this.redisClient.quit();
                console.log('Redis connection closed');
            } catch (error) {
                console.error('Error closing Redis connection:', error);
            }
        }
        
        // Clear in-memory sessions if they exist (fallback)
        if (this.sessions) {
            this.sessions.clear();
        }
    }
}
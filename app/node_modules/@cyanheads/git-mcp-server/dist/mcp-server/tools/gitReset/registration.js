import { BaseErrorCode } from "../../../types-global/errors.js"; // Direct import for types-global
import { ErrorHandler, logger, requestContextService, } from "../../../utils/index.js"; // ErrorHandler (./utils/internal/errorHandler.js), logger (./utils/internal/logger.js), requestContextService & RequestContext (./utils/internal/requestContext.js)
import { GitResetInputSchema, resetGitState, } from "./logic.js";
let _getWorkingDirectory;
let _getSessionId;
/**
 * Initializes the state accessors needed by the tool registration.
 * This should be called once during server setup.
 * @param getWdFn - Function to get the working directory for a session.
 * @param getSidFn - Function to get the session ID from context.
 */
export function initializeGitResetStateAccessors(getWdFn, getSidFn) {
    _getWorkingDirectory = getWdFn;
    _getSessionId = getSidFn;
    logger.info("State accessors initialized for git_reset tool registration.");
}
const TOOL_NAME = "git_reset";
const TOOL_DESCRIPTION = "Resets the current HEAD to a specified state. Supports different modes ('soft', 'mixed', 'hard', 'merge', 'keep') to control how the index and working tree are affected. Can reset to a specific commit. USE 'hard' MODE WITH EXTREME CAUTION as it discards local changes.";
/**
 * Registers the git_reset tool with the MCP server.
 *
 * @param {McpServer} server - The MCP server instance.
 * @throws {Error} If state accessors are not initialized.
 */
export async function registerGitResetTool(server) {
    if (!_getWorkingDirectory || !_getSessionId) {
        throw new Error("State accessors for git_reset must be initialized before registration.");
    }
    const operation = "registerGitResetTool";
    const context = requestContextService.createRequestContext({ operation });
    await ErrorHandler.tryCatch(async () => {
        server.tool(TOOL_NAME, TOOL_DESCRIPTION, GitResetInputSchema.shape, // Provide the Zod schema shape
        async (validatedArgs, callContext) => {
            const toolOperation = "tool:git_reset";
            const requestContext = requestContextService.createRequestContext({
                operation: toolOperation,
                parentContext: callContext,
            });
            const sessionId = _getSessionId(requestContext);
            const getWorkingDirectoryForSession = () => {
                return _getWorkingDirectory(sessionId);
            };
            const logicContext = {
                ...requestContext,
                sessionId: sessionId,
                getWorkingDirectory: getWorkingDirectoryForSession,
            };
            logger.info(`Executing tool: ${TOOL_NAME}`, logicContext);
            return await ErrorHandler.tryCatch(async () => {
                // Call the core logic function
                const resetResult = await resetGitState(validatedArgs, logicContext);
                // Format the result as a JSON string within TextContent
                const resultContent = {
                    type: "text",
                    // Stringify the entire GitResetResult object
                    text: JSON.stringify(resetResult, null, 2), // Pretty-print JSON
                    contentType: "application/json",
                };
                logger.info(`Tool ${TOOL_NAME} executed successfully: ${resetResult.message}`, logicContext);
                // Success is determined by the logic function and included in the result object
                return { content: [resultContent] };
            }, {
                operation: toolOperation,
                context: logicContext,
                input: validatedArgs,
                errorCode: BaseErrorCode.INTERNAL_ERROR, // Default if unexpected error in logic
            });
        });
        logger.info(`Tool registered: ${TOOL_NAME}`, context);
    }, { operation, context, critical: true });
}

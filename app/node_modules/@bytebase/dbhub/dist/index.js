#!/usr/bin/env node

// src/connectors/postgres/index.ts
import pg from "pg";

// src/connectors/interface.ts
var _ConnectorRegistry = class _ConnectorRegistry {
  /**
   * Register a new connector
   */
  static register(connector) {
    _ConnectorRegistry.connectors.set(connector.id, connector);
  }
  /**
   * Get a connector by ID
   */
  static getConnector(id) {
    return _ConnectorRegistry.connectors.get(id) || null;
  }
  /**
   * Get connector for a DSN string
   * Tries to find a connector that can handle the given DSN format
   */
  static getConnectorForDSN(dsn) {
    for (const connector of _ConnectorRegistry.connectors.values()) {
      if (connector.dsnParser.isValidDSN(dsn)) {
        return connector;
      }
    }
    return null;
  }
  /**
   * Get all available connector IDs
   */
  static getAvailableConnectors() {
    return Array.from(_ConnectorRegistry.connectors.keys());
  }
  /**
   * Get sample DSN for a specific connector
   */
  static getSampleDSN(connectorType) {
    const connector = _ConnectorRegistry.getConnector(connectorType);
    if (!connector) return null;
    return connector.dsnParser.getSampleDSN();
  }
  /**
   * Get all available sample DSNs
   */
  static getAllSampleDSNs() {
    const samples = {};
    for (const [id, connector] of _ConnectorRegistry.connectors.entries()) {
      samples[id] = connector.dsnParser.getSampleDSN();
    }
    return samples;
  }
};
_ConnectorRegistry.connectors = /* @__PURE__ */ new Map();
var ConnectorRegistry = _ConnectorRegistry;

// src/utils/safe-url.ts
var SafeURL = class {
  /**
   * Parse a URL and handle special characters in passwords
   * This is a safe alternative to the URL constructor
   * 
   * @param urlString - The DSN string to parse
   */
  constructor(urlString) {
    this.protocol = "";
    this.hostname = "";
    this.port = "";
    this.pathname = "";
    this.username = "";
    this.password = "";
    this.searchParams = /* @__PURE__ */ new Map();
    if (!urlString || urlString.trim() === "") {
      throw new Error("URL string cannot be empty");
    }
    try {
      const protocolSeparator = urlString.indexOf("://");
      if (protocolSeparator !== -1) {
        this.protocol = urlString.substring(0, protocolSeparator + 1);
        urlString = urlString.substring(protocolSeparator + 3);
      } else {
        throw new Error('Invalid URL format: missing protocol (e.g., "mysql://")');
      }
      const questionMarkIndex = urlString.indexOf("?");
      let queryParams = "";
      if (questionMarkIndex !== -1) {
        queryParams = urlString.substring(questionMarkIndex + 1);
        urlString = urlString.substring(0, questionMarkIndex);
        queryParams.split("&").forEach((pair) => {
          const parts = pair.split("=");
          if (parts.length === 2 && parts[0] && parts[1]) {
            this.searchParams.set(parts[0], decodeURIComponent(parts[1]));
          }
        });
      }
      const atIndex = urlString.indexOf("@");
      if (atIndex !== -1) {
        const auth = urlString.substring(0, atIndex);
        urlString = urlString.substring(atIndex + 1);
        const colonIndex2 = auth.indexOf(":");
        if (colonIndex2 !== -1) {
          this.username = auth.substring(0, colonIndex2);
          this.password = auth.substring(colonIndex2 + 1);
          this.username = decodeURIComponent(this.username);
          this.password = decodeURIComponent(this.password);
        } else {
          this.username = auth;
        }
      }
      const pathSeparatorIndex = urlString.indexOf("/");
      if (pathSeparatorIndex !== -1) {
        this.pathname = urlString.substring(pathSeparatorIndex);
        urlString = urlString.substring(0, pathSeparatorIndex);
      }
      const colonIndex = urlString.indexOf(":");
      if (colonIndex !== -1) {
        this.hostname = urlString.substring(0, colonIndex);
        this.port = urlString.substring(colonIndex + 1);
      } else {
        this.hostname = urlString;
      }
      if (this.protocol === "") {
        throw new Error("Invalid URL: protocol is required");
      }
    } catch (error) {
      throw new Error(`Failed to parse URL: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Helper method to safely get a parameter from query string
   * 
   * @param name - The parameter name to retrieve
   * @returns The parameter value or null if not found
   */
  getSearchParam(name) {
    return this.searchParams.has(name) ? this.searchParams.get(name) : null;
  }
  /**
   * Helper method to iterate over all parameters
   * 
   * @param callback - Function to call for each parameter
   */
  forEachSearchParam(callback) {
    this.searchParams.forEach((value, key) => callback(value, key));
  }
};

// src/utils/dsn-obfuscate.ts
function obfuscateDSNPassword(dsn) {
  if (!dsn) {
    return dsn;
  }
  try {
    const protocolMatch = dsn.match(/^([^:]+):/);
    if (!protocolMatch) {
      return dsn;
    }
    const protocol = protocolMatch[1];
    if (protocol === "sqlite") {
      return dsn;
    }
    const protocolPart = dsn.split("://")[1];
    if (!protocolPart) {
      return dsn;
    }
    const lastAtIndex = protocolPart.lastIndexOf("@");
    if (lastAtIndex === -1) {
      return dsn;
    }
    const credentialsPart = protocolPart.substring(0, lastAtIndex);
    const hostPart = protocolPart.substring(lastAtIndex + 1);
    const colonIndex = credentialsPart.indexOf(":");
    if (colonIndex === -1) {
      return dsn;
    }
    const username = credentialsPart.substring(0, colonIndex);
    const password = credentialsPart.substring(colonIndex + 1);
    const obfuscatedPassword = "*".repeat(Math.min(password.length, 8));
    return `${protocol}://${username}:${obfuscatedPassword}@${hostPart}`;
  } catch (error) {
    return dsn;
  }
}

// src/connectors/postgres/index.ts
var { Pool } = pg;
var PostgresDSNParser = class {
  async parse(dsn) {
    if (!this.isValidDSN(dsn)) {
      const obfuscatedDSN = obfuscateDSNPassword(dsn);
      const expectedFormat = this.getSampleDSN();
      throw new Error(
        `Invalid PostgreSQL DSN format.
Provided: ${obfuscatedDSN}
Expected: ${expectedFormat}`
      );
    }
    try {
      const url = new SafeURL(dsn);
      const config = {
        host: url.hostname,
        port: url.port ? parseInt(url.port) : 5432,
        database: url.pathname ? url.pathname.substring(1) : "",
        // Remove leading '/' if exists
        user: url.username,
        password: url.password
      };
      url.forEachSearchParam((value, key) => {
        if (key === "sslmode") {
          if (value === "disable") {
            config.ssl = false;
          } else if (value === "require") {
            config.ssl = { rejectUnauthorized: false };
          } else {
            config.ssl = true;
          }
        }
      });
      return config;
    } catch (error) {
      throw new Error(
        `Failed to parse PostgreSQL DSN: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getSampleDSN() {
    return "postgres://postgres:password@localhost:5432/postgres?sslmode=require";
  }
  isValidDSN(dsn) {
    try {
      return dsn.startsWith("postgres://") || dsn.startsWith("postgresql://");
    } catch (error) {
      return false;
    }
  }
};
var PostgresConnector = class {
  constructor() {
    this.id = "postgres";
    this.name = "PostgreSQL";
    this.dsnParser = new PostgresDSNParser();
    this.pool = null;
  }
  async connect(dsn) {
    try {
      const config = await this.dsnParser.parse(dsn);
      this.pool = new Pool(config);
      const client = await this.pool.connect();
      console.error("Successfully connected to PostgreSQL database");
      client.release();
    } catch (err) {
      console.error("Failed to connect to PostgreSQL database:", err);
      throw err;
    }
  }
  async disconnect() {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
    }
  }
  async getSchemas() {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema', 'pg_toast')
        ORDER BY schema_name
      `);
      return result.rows.map((row) => row.schema_name);
    } finally {
      client.release();
    }
  }
  async getTables(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = $1
        ORDER BY table_name
      `,
        [schemaToUse]
      );
      return result.rows.map((row) => row.table_name);
    } finally {
      client.release();
    }
  }
  async tableExists(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = $1 
          AND table_name = $2
        )
      `,
        [schemaToUse, tableName]
      );
      return result.rows[0].exists;
    } finally {
      client.release();
    }
  }
  async getTableIndexes(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT 
          i.relname as index_name,
          array_agg(a.attname) as column_names,
          ix.indisunique as is_unique,
          ix.indisprimary as is_primary
        FROM 
          pg_class t,
          pg_class i,
          pg_index ix,
          pg_attribute a,
          pg_namespace ns
        WHERE 
          t.oid = ix.indrelid
          AND i.oid = ix.indexrelid
          AND a.attrelid = t.oid
          AND a.attnum = ANY(ix.indkey)
          AND t.relkind = 'r'
          AND t.relname = $1
          AND ns.oid = t.relnamespace
          AND ns.nspname = $2
        GROUP BY 
          i.relname, 
          ix.indisunique,
          ix.indisprimary
        ORDER BY 
          i.relname
      `,
        [tableName, schemaToUse]
      );
      return result.rows.map((row) => ({
        index_name: row.index_name,
        column_names: row.column_names,
        is_unique: row.is_unique,
        is_primary: row.is_primary
      }));
    } finally {
      client.release();
    }
  }
  async getTableSchema(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT 
          column_name, 
          data_type, 
          is_nullable,
          column_default
        FROM information_schema.columns
        WHERE table_schema = $1
        AND table_name = $2
        ORDER BY ordinal_position
      `,
        [schemaToUse, tableName]
      );
      return result.rows;
    } finally {
      client.release();
    }
  }
  async getStoredProcedures(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT 
          routine_name
        FROM information_schema.routines
        WHERE routine_schema = $1
        ORDER BY routine_name
      `,
        [schemaToUse]
      );
      return result.rows.map((row) => row.routine_name);
    } finally {
      client.release();
    }
  }
  async getStoredProcedureDetail(procedureName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const schemaToUse = schema || "public";
      const result = await client.query(
        `
        SELECT 
          routine_name as procedure_name,
          routine_type,
          CASE WHEN routine_type = 'PROCEDURE' THEN 'procedure' ELSE 'function' END as procedure_type,
          external_language as language,
          data_type as return_type,
          routine_definition as definition,
          (
            SELECT string_agg(
              parameter_name || ' ' || 
              parameter_mode || ' ' || 
              data_type,
              ', '
            )
            FROM information_schema.parameters
            WHERE specific_schema = $1
            AND specific_name = $2
            AND parameter_name IS NOT NULL
          ) as parameter_list
        FROM information_schema.routines
        WHERE routine_schema = $1
        AND routine_name = $2
      `,
        [schemaToUse, procedureName]
      );
      if (result.rows.length === 0) {
        throw new Error(`Stored procedure '${procedureName}' not found in schema '${schemaToUse}'`);
      }
      const procedure = result.rows[0];
      let definition = procedure.definition;
      try {
        const oidResult = await client.query(
          `
          SELECT p.oid, p.prosrc
          FROM pg_proc p
          JOIN pg_namespace n ON p.pronamespace = n.oid
          WHERE p.proname = $1
          AND n.nspname = $2
        `,
          [procedureName, schemaToUse]
        );
        if (oidResult.rows.length > 0) {
          if (!definition) {
            const oid = oidResult.rows[0].oid;
            const defResult = await client.query(`SELECT pg_get_functiondef($1)`, [oid]);
            if (defResult.rows.length > 0) {
              definition = defResult.rows[0].pg_get_functiondef;
            } else {
              definition = oidResult.rows[0].prosrc;
            }
          }
        }
      } catch (err) {
        console.error(`Error getting procedure definition: ${err}`);
      }
      return {
        procedure_name: procedure.procedure_name,
        procedure_type: procedure.procedure_type,
        language: procedure.language || "sql",
        parameter_list: procedure.parameter_list || "",
        return_type: procedure.return_type !== "void" ? procedure.return_type : void 0,
        definition: definition || void 0
      };
    } finally {
      client.release();
    }
  }
  async executeSQL(sql2) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    const client = await this.pool.connect();
    try {
      const statements = sql2.split(";").map((statement) => statement.trim()).filter((statement) => statement.length > 0);
      if (statements.length === 1) {
        return await client.query(statements[0]);
      } else {
        let allRows = [];
        await client.query("BEGIN");
        try {
          for (const statement of statements) {
            const result = await client.query(statement);
            if (result.rows && result.rows.length > 0) {
              allRows.push(...result.rows);
            }
          }
          await client.query("COMMIT");
        } catch (error) {
          await client.query("ROLLBACK");
          throw error;
        }
        return { rows: allRows };
      }
    } finally {
      client.release();
    }
  }
};
var postgresConnector = new PostgresConnector();
ConnectorRegistry.register(postgresConnector);

// src/connectors/sqlserver/index.ts
import sql from "mssql";
import { DefaultAzureCredential } from "@azure/identity";
var SQLServerDSNParser = class {
  async parse(dsn) {
    if (!this.isValidDSN(dsn)) {
      const obfuscatedDSN = obfuscateDSNPassword(dsn);
      const expectedFormat = this.getSampleDSN();
      throw new Error(
        `Invalid SQL Server DSN format.
Provided: ${obfuscatedDSN}
Expected: ${expectedFormat}`
      );
    }
    try {
      const url = new SafeURL(dsn);
      const options = {};
      url.forEachSearchParam((value, key) => {
        if (key === "connectTimeout") {
          options.connectTimeout = parseInt(value, 10);
        } else if (key === "requestTimeout") {
          options.requestTimeout = parseInt(value, 10);
        } else if (key === "authentication") {
          options.authentication = value;
        } else if (key === "sslmode") {
          options.sslmode = value;
        }
      });
      if (options.sslmode) {
        if (options.sslmode === "disable") {
          options.encrypt = false;
          options.trustServerCertificate = false;
        } else if (options.sslmode === "require") {
          options.encrypt = true;
          options.trustServerCertificate = true;
        }
      }
      const config = {
        user: url.username,
        password: url.password,
        server: url.hostname,
        port: url.port ? parseInt(url.port) : 1433,
        // Default SQL Server port
        database: url.pathname ? url.pathname.substring(1) : "",
        // Remove leading slash
        options: {
          encrypt: options.encrypt ?? false,
          // Default to unencrypted for development
          trustServerCertificate: options.trustServerCertificate ?? false,
          connectTimeout: options.connectTimeout ?? 15e3,
          requestTimeout: options.requestTimeout ?? 15e3
        }
      };
      if (options.authentication === "azure-active-directory-access-token") {
        try {
          const credential = new DefaultAzureCredential();
          const token = await credential.getToken("https://database.windows.net/");
          config.authentication = {
            type: "azure-active-directory-access-token",
            options: {
              token: token.token
            }
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          throw new Error(`Failed to get Azure AD token: ${errorMessage}`);
        }
      }
      return config;
    } catch (error) {
      throw new Error(
        `Failed to parse SQL Server DSN: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getSampleDSN() {
    return "sqlserver://username:password@localhost:1433/database?sslmode=disable";
  }
  isValidDSN(dsn) {
    try {
      return dsn.startsWith("sqlserver://");
    } catch (error) {
      return false;
    }
  }
};
var SQLServerConnector = class {
  constructor() {
    this.id = "sqlserver";
    this.name = "SQL Server";
    this.dsnParser = new SQLServerDSNParser();
  }
  async connect(dsn) {
    try {
      this.config = await this.dsnParser.parse(dsn);
      if (!this.config.options) {
        this.config.options = {};
      }
      this.connection = await new sql.ConnectionPool(this.config).connect();
    } catch (error) {
      throw error;
    }
  }
  async disconnect() {
    if (this.connection) {
      await this.connection.close();
      this.connection = void 0;
    }
  }
  async getSchemas() {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const result = await this.connection.request().query(`
          SELECT SCHEMA_NAME
          FROM INFORMATION_SCHEMA.SCHEMATA
          ORDER BY SCHEMA_NAME
      `);
      return result.recordset.map((row) => row.SCHEMA_NAME);
    } catch (error) {
      throw new Error(`Failed to get schemas: ${error.message}`);
    }
  }
  async getTables(schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("schema", sql.VarChar, schemaToUse);
      const query = `
          SELECT TABLE_NAME
          FROM INFORMATION_SCHEMA.TABLES
          WHERE TABLE_SCHEMA = @schema
          ORDER BY TABLE_NAME
      `;
      const result = await request.query(query);
      return result.recordset.map((row) => row.TABLE_NAME);
    } catch (error) {
      throw new Error(`Failed to get tables: ${error.message}`);
    }
  }
  async tableExists(tableName, schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("tableName", sql.VarChar, tableName).input("schema", sql.VarChar, schemaToUse);
      const query = `
          SELECT COUNT(*) as count
          FROM INFORMATION_SCHEMA.TABLES
          WHERE TABLE_NAME = @tableName
            AND TABLE_SCHEMA = @schema
      `;
      const result = await request.query(query);
      return result.recordset[0].count > 0;
    } catch (error) {
      throw new Error(`Failed to check if table exists: ${error.message}`);
    }
  }
  async getTableIndexes(tableName, schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("tableName", sql.VarChar, tableName).input("schema", sql.VarChar, schemaToUse);
      const query = `
          SELECT i.name AS index_name,
                 i.is_unique,
                 i.is_primary_key,
                 c.name AS column_name,
                 ic.key_ordinal
          FROM sys.indexes i
                   INNER JOIN
               sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id
                   INNER JOIN
               sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
                   INNER JOIN
               sys.tables t ON i.object_id = t.object_id
                   INNER JOIN
               sys.schemas s ON t.schema_id = s.schema_id
          WHERE t.name = @tableName
            AND s.name = @schema
          ORDER BY i.name,
                   ic.key_ordinal
      `;
      const result = await request.query(query);
      const indexMap = /* @__PURE__ */ new Map();
      for (const row of result.recordset) {
        const indexName = row.index_name;
        const columnName = row.column_name;
        const isUnique = !!row.is_unique;
        const isPrimary = !!row.is_primary_key;
        if (!indexMap.has(indexName)) {
          indexMap.set(indexName, {
            columns: [],
            is_unique: isUnique,
            is_primary: isPrimary
          });
        }
        const indexInfo = indexMap.get(indexName);
        indexInfo.columns.push(columnName);
      }
      const indexes = [];
      indexMap.forEach((info, name) => {
        indexes.push({
          index_name: name,
          column_names: info.columns,
          is_unique: info.is_unique,
          is_primary: info.is_primary
        });
      });
      return indexes;
    } catch (error) {
      throw new Error(`Failed to get indexes for table ${tableName}: ${error.message}`);
    }
  }
  async getTableSchema(tableName, schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("tableName", sql.VarChar, tableName).input("schema", sql.VarChar, schemaToUse);
      const query = `
          SELECT COLUMN_NAME as    column_name,
                 DATA_TYPE as      data_type,
                 IS_NULLABLE as    is_nullable,
                 COLUMN_DEFAULT as column_default
          FROM INFORMATION_SCHEMA.COLUMNS
          WHERE TABLE_NAME = @tableName
            AND TABLE_SCHEMA = @schema
          ORDER BY ORDINAL_POSITION
      `;
      const result = await request.query(query);
      return result.recordset;
    } catch (error) {
      throw new Error(`Failed to get schema for table ${tableName}: ${error.message}`);
    }
  }
  async getStoredProcedures(schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("schema", sql.VarChar, schemaToUse);
      const query = `
          SELECT ROUTINE_NAME
          FROM INFORMATION_SCHEMA.ROUTINES
          WHERE ROUTINE_SCHEMA = @schema
            AND (ROUTINE_TYPE = 'PROCEDURE' OR ROUTINE_TYPE = 'FUNCTION')
          ORDER BY ROUTINE_NAME
      `;
      const result = await request.query(query);
      return result.recordset.map((row) => row.ROUTINE_NAME);
    } catch (error) {
      throw new Error(`Failed to get stored procedures: ${error.message}`);
    }
  }
  async getStoredProcedureDetail(procedureName, schema) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const schemaToUse = schema || "dbo";
      const request = this.connection.request().input("procedureName", sql.VarChar, procedureName).input("schema", sql.VarChar, schemaToUse);
      const routineQuery = `
          SELECT ROUTINE_NAME as procedure_name,
                 ROUTINE_TYPE,
                 DATA_TYPE    as return_data_type
          FROM INFORMATION_SCHEMA.ROUTINES
          WHERE ROUTINE_NAME = @procedureName
            AND ROUTINE_SCHEMA = @schema
      `;
      const routineResult = await request.query(routineQuery);
      if (routineResult.recordset.length === 0) {
        throw new Error(`Stored procedure '${procedureName}' not found in schema '${schemaToUse}'`);
      }
      const routine = routineResult.recordset[0];
      const parameterQuery = `
          SELECT PARAMETER_NAME,
                 PARAMETER_MODE,
                 DATA_TYPE,
                 CHARACTER_MAXIMUM_LENGTH,
                 ORDINAL_POSITION
          FROM INFORMATION_SCHEMA.PARAMETERS
          WHERE SPECIFIC_NAME = @procedureName
            AND SPECIFIC_SCHEMA = @schema
          ORDER BY ORDINAL_POSITION
      `;
      const parameterResult = await request.query(parameterQuery);
      let parameterList = "";
      if (parameterResult.recordset.length > 0) {
        parameterList = parameterResult.recordset.map(
          (param) => {
            const lengthStr = param.CHARACTER_MAXIMUM_LENGTH > 0 ? `(${param.CHARACTER_MAXIMUM_LENGTH})` : "";
            return `${param.PARAMETER_NAME} ${param.PARAMETER_MODE} ${param.DATA_TYPE}${lengthStr}`;
          }
        ).join(", ");
      }
      const definitionQuery = `
          SELECT definition
          FROM sys.sql_modules sm
                   JOIN sys.objects o ON sm.object_id = o.object_id
                   JOIN sys.schemas s ON o.schema_id = s.schema_id
          WHERE o.name = @procedureName
            AND s.name = @schema
      `;
      const definitionResult = await request.query(definitionQuery);
      let definition = void 0;
      if (definitionResult.recordset.length > 0) {
        definition = definitionResult.recordset[0].definition;
      }
      return {
        procedure_name: routine.procedure_name,
        procedure_type: routine.ROUTINE_TYPE === "PROCEDURE" ? "procedure" : "function",
        language: "sql",
        // SQL Server procedures are typically in T-SQL
        parameter_list: parameterList,
        return_type: routine.ROUTINE_TYPE === "FUNCTION" ? routine.return_data_type : void 0,
        definition
      };
    } catch (error) {
      throw new Error(`Failed to get stored procedure details: ${error.message}`);
    }
  }
  async executeSQL(sql2) {
    if (!this.connection) {
      throw new Error("Not connected to SQL Server database");
    }
    try {
      const result = await this.connection.request().query(sql2);
      return {
        rows: result.recordset || [],
        fields: result.recordset && result.recordset.length > 0 ? Object.keys(result.recordset[0]).map((key) => ({
          name: key
        })) : [],
        rowCount: result.rowsAffected[0] || 0
      };
    } catch (error) {
      throw new Error(`Failed to execute query: ${error.message}`);
    }
  }
};
var sqlServerConnector = new SQLServerConnector();
ConnectorRegistry.register(sqlServerConnector);

// src/connectors/sqlite/index.ts
import Database from "better-sqlite3";
var SQLiteDSNParser = class {
  async parse(dsn) {
    if (!this.isValidDSN(dsn)) {
      const obfuscatedDSN = obfuscateDSNPassword(dsn);
      const expectedFormat = this.getSampleDSN();
      throw new Error(
        `Invalid SQLite DSN format.
Provided: ${obfuscatedDSN}
Expected: ${expectedFormat}`
      );
    }
    try {
      const url = new SafeURL(dsn);
      let dbPath;
      if (url.hostname === "" && url.pathname === "/:memory:") {
        dbPath = ":memory:";
      } else {
        if (url.pathname.startsWith("//")) {
          dbPath = url.pathname.substring(2);
        } else {
          dbPath = url.pathname;
        }
      }
      return { dbPath };
    } catch (error) {
      throw new Error(
        `Failed to parse SQLite DSN: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getSampleDSN() {
    return "sqlite:///path/to/database.db";
  }
  isValidDSN(dsn) {
    try {
      return dsn.startsWith("sqlite://");
    } catch (error) {
      return false;
    }
  }
};
var SQLiteConnector = class {
  constructor() {
    this.id = "sqlite";
    this.name = "SQLite";
    this.dsnParser = new SQLiteDSNParser();
    this.db = null;
    this.dbPath = ":memory:";
  }
  // Default to in-memory database
  async connect(dsn, initScript) {
    const config = await this.dsnParser.parse(dsn);
    this.dbPath = config.dbPath;
    try {
      this.db = new Database(this.dbPath);
      console.error("Successfully connected to SQLite database");
      if (initScript) {
        this.db.exec(initScript);
        console.error("Successfully initialized database with script");
      }
    } catch (error) {
      console.error("Failed to connect to SQLite database:", error);
      throw error;
    }
  }
  async disconnect() {
    if (this.db) {
      try {
        this.db.close();
        this.db = null;
      } catch (error) {
        throw error;
      }
    }
    return Promise.resolve();
  }
  async getSchemas() {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    return ["main"];
  }
  async getTables(schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    try {
      const rows = this.db.prepare(
        `
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name NOT LIKE 'sqlite_%'
        ORDER BY name
      `
      ).all();
      return rows.map((row) => row.name);
    } catch (error) {
      throw error;
    }
  }
  async tableExists(tableName, schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    try {
      const row = this.db.prepare(
        `
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name = ?
      `
      ).get(tableName);
      return !!row;
    } catch (error) {
      throw error;
    }
  }
  async getTableIndexes(tableName, schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    try {
      const indexInfoRows = this.db.prepare(
        `
        SELECT 
          name as index_name,
          0 as is_unique
        FROM sqlite_master 
        WHERE type = 'index' 
        AND tbl_name = ?
      `
      ).all(tableName);
      const indexListRows = this.db.prepare(`PRAGMA index_list(${tableName})`).all();
      const indexUniqueMap = /* @__PURE__ */ new Map();
      for (const indexListRow of indexListRows) {
        indexUniqueMap.set(indexListRow.name, indexListRow.unique === 1);
      }
      const tableInfo = this.db.prepare(`PRAGMA table_info(${tableName})`).all();
      const pkColumns = tableInfo.filter((col) => col.pk > 0).map((col) => col.name);
      const results = [];
      for (const indexInfo of indexInfoRows) {
        const indexDetailRows = this.db.prepare(`PRAGMA index_info(${indexInfo.index_name})`).all();
        const columnNames = indexDetailRows.map((row) => row.name);
        results.push({
          index_name: indexInfo.index_name,
          column_names: columnNames,
          is_unique: indexUniqueMap.get(indexInfo.index_name) || false,
          is_primary: false
        });
      }
      if (pkColumns.length > 0) {
        results.push({
          index_name: "PRIMARY",
          column_names: pkColumns,
          is_unique: true,
          is_primary: true
        });
      }
      return results;
    } catch (error) {
      throw error;
    }
  }
  async getTableSchema(tableName, schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    try {
      const rows = this.db.prepare(`PRAGMA table_info(${tableName})`).all();
      const columns = rows.map((row) => ({
        column_name: row.name,
        data_type: row.type,
        // In SQLite, primary key columns are automatically NOT NULL even if notnull=0
        is_nullable: row.notnull === 1 || row.pk > 0 ? "NO" : "YES",
        column_default: row.dflt_value
      }));
      return columns;
    } catch (error) {
      throw error;
    }
  }
  async getStoredProcedures(schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    return [];
  }
  async getStoredProcedureDetail(procedureName, schema) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    throw new Error(
      "SQLite does not support stored procedures. Functions are defined programmatically through the SQLite API, not stored in the database."
    );
  }
  async executeSQL(sql2) {
    if (!this.db) {
      throw new Error("Not connected to SQLite database");
    }
    try {
      const statements = sql2.split(";").map((statement) => statement.trim()).filter((statement) => statement.length > 0);
      if (statements.length === 1) {
        const trimmedStatement = statements[0].toLowerCase().trim();
        const isReadStatement = trimmedStatement.startsWith("select") || trimmedStatement.startsWith("with") || trimmedStatement.startsWith("explain") || trimmedStatement.startsWith("analyze") || trimmedStatement.startsWith("pragma") && (trimmedStatement.includes("table_info") || trimmedStatement.includes("index_info") || trimmedStatement.includes("index_list") || trimmedStatement.includes("foreign_key_list"));
        if (isReadStatement) {
          const rows = this.db.prepare(statements[0]).all();
          return { rows };
        } else {
          this.db.prepare(statements[0]).run();
          return { rows: [] };
        }
      } else {
        const readStatements = [];
        const writeStatements = [];
        for (const statement of statements) {
          const trimmedStatement = statement.toLowerCase().trim();
          if (trimmedStatement.startsWith("select") || trimmedStatement.startsWith("with") || trimmedStatement.startsWith("explain") || trimmedStatement.startsWith("analyze") || trimmedStatement.startsWith("pragma") && (trimmedStatement.includes("table_info") || trimmedStatement.includes("index_info") || trimmedStatement.includes("index_list") || trimmedStatement.includes("foreign_key_list"))) {
            readStatements.push(statement);
          } else {
            writeStatements.push(statement);
          }
        }
        if (writeStatements.length > 0) {
          this.db.exec(writeStatements.join("; "));
        }
        let allRows = [];
        for (const statement of readStatements) {
          const result = this.db.prepare(statement).all();
          allRows.push(...result);
        }
        return { rows: allRows };
      }
    } catch (error) {
      throw error;
    }
  }
};
var sqliteConnector = new SQLiteConnector();
ConnectorRegistry.register(sqliteConnector);

// src/connectors/mysql/index.ts
import mysql from "mysql2/promise";
var MySQLDSNParser = class {
  async parse(dsn) {
    if (!this.isValidDSN(dsn)) {
      const obfuscatedDSN = obfuscateDSNPassword(dsn);
      const expectedFormat = this.getSampleDSN();
      throw new Error(
        `Invalid MySQL DSN format.
Provided: ${obfuscatedDSN}
Expected: ${expectedFormat}`
      );
    }
    try {
      const url = new SafeURL(dsn);
      const config = {
        host: url.hostname,
        port: url.port ? parseInt(url.port) : 3306,
        database: url.pathname ? url.pathname.substring(1) : "",
        // Remove leading '/' if exists
        user: url.username,
        password: url.password,
        multipleStatements: true
        // Enable native multi-statement support
      };
      url.forEachSearchParam((value, key) => {
        if (key === "sslmode") {
          if (value === "disable") {
            config.ssl = void 0;
          } else if (value === "require") {
            config.ssl = { rejectUnauthorized: false };
          } else {
            config.ssl = {};
          }
        }
      });
      return config;
    } catch (error) {
      throw new Error(
        `Failed to parse MySQL DSN: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getSampleDSN() {
    return "mysql://root:password@localhost:3306/mysql?sslmode=require";
  }
  isValidDSN(dsn) {
    try {
      return dsn.startsWith("mysql://");
    } catch (error) {
      return false;
    }
  }
};
var MySQLConnector = class {
  constructor() {
    this.id = "mysql";
    this.name = "MySQL";
    this.dsnParser = new MySQLDSNParser();
    this.pool = null;
  }
  async connect(dsn) {
    try {
      const config = await this.dsnParser.parse(dsn);
      this.pool = mysql.createPool(config);
      const [rows] = await this.pool.query("SELECT 1");
      console.error("Successfully connected to MySQL database");
    } catch (err) {
      console.error("Failed to connect to MySQL database:", err);
      throw err;
    }
  }
  async disconnect() {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
    }
  }
  async getSchemas() {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const [rows] = await this.pool.query(`
        SELECT SCHEMA_NAME 
        FROM INFORMATION_SCHEMA.SCHEMATA
        ORDER BY SCHEMA_NAME
      `);
      return rows.map((row) => row.SCHEMA_NAME);
    } catch (error) {
      console.error("Error getting schemas:", error);
      throw error;
    }
  }
  async getTables(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema] : [];
      const [rows] = await this.pool.query(
        `
        SELECT TABLE_NAME 
        FROM INFORMATION_SCHEMA.TABLES 
        ${schemaClause}
        ORDER BY TABLE_NAME
      `,
        queryParams
      );
      return rows.map((row) => row.TABLE_NAME);
    } catch (error) {
      console.error("Error getting tables:", error);
      throw error;
    }
  }
  async tableExists(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const [rows] = await this.pool.query(
        `
        SELECT COUNT(*) AS COUNT
        FROM INFORMATION_SCHEMA.TABLES 
        ${schemaClause} 
        AND TABLE_NAME = ?
      `,
        queryParams
      );
      return rows[0].COUNT > 0;
    } catch (error) {
      console.error("Error checking if table exists:", error);
      throw error;
    }
  }
  async getTableIndexes(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "TABLE_SCHEMA = ?" : "TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const [indexRows] = await this.pool.query(
        `
        SELECT 
          INDEX_NAME,
          COLUMN_NAME,
          NON_UNIQUE,
          SEQ_IN_INDEX
        FROM 
          INFORMATION_SCHEMA.STATISTICS 
        WHERE 
          ${schemaClause}
          AND TABLE_NAME = ? 
        ORDER BY 
          INDEX_NAME, 
          SEQ_IN_INDEX
      `,
        queryParams
      );
      const indexMap = /* @__PURE__ */ new Map();
      for (const row of indexRows) {
        const indexName = row.INDEX_NAME;
        const columnName = row.COLUMN_NAME;
        const isUnique = row.NON_UNIQUE === 0;
        const isPrimary = indexName === "PRIMARY";
        if (!indexMap.has(indexName)) {
          indexMap.set(indexName, {
            columns: [],
            is_unique: isUnique,
            is_primary: isPrimary
          });
        }
        const indexInfo = indexMap.get(indexName);
        indexInfo.columns.push(columnName);
      }
      const results = [];
      indexMap.forEach((indexInfo, indexName) => {
        results.push({
          index_name: indexName,
          column_names: indexInfo.columns,
          is_unique: indexInfo.is_unique,
          is_primary: indexInfo.is_primary
        });
      });
      return results;
    } catch (error) {
      console.error("Error getting table indexes:", error);
      throw error;
    }
  }
  async getTableSchema(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const [rows] = await this.pool.query(
        `
        SELECT 
          COLUMN_NAME as column_name, 
          DATA_TYPE as data_type, 
          IS_NULLABLE as is_nullable,
          COLUMN_DEFAULT as column_default
        FROM INFORMATION_SCHEMA.COLUMNS
        ${schemaClause}
        AND TABLE_NAME = ?
        ORDER BY ORDINAL_POSITION
      `,
        queryParams
      );
      return rows;
    } catch (error) {
      console.error("Error getting table schema:", error);
      throw error;
    }
  }
  async getStoredProcedures(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE ROUTINE_SCHEMA = ?" : "WHERE ROUTINE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema] : [];
      const [rows] = await this.pool.query(
        `
        SELECT ROUTINE_NAME
        FROM INFORMATION_SCHEMA.ROUTINES
        ${schemaClause}
        ORDER BY ROUTINE_NAME
      `,
        queryParams
      );
      return rows.map((row) => row.ROUTINE_NAME);
    } catch (error) {
      console.error("Error getting stored procedures:", error);
      throw error;
    }
  }
  async getStoredProcedureDetail(procedureName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE r.ROUTINE_SCHEMA = ?" : "WHERE r.ROUTINE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, procedureName] : [procedureName];
      const [rows] = await this.pool.query(
        `
        SELECT 
          r.ROUTINE_NAME AS procedure_name,
          CASE 
            WHEN r.ROUTINE_TYPE = 'PROCEDURE' THEN 'procedure'
            ELSE 'function'
          END AS procedure_type,
          LOWER(r.ROUTINE_TYPE) AS routine_type,
          r.ROUTINE_DEFINITION,
          r.DTD_IDENTIFIER AS return_type,
          (
            SELECT GROUP_CONCAT(
              CONCAT(p.PARAMETER_NAME, ' ', p.PARAMETER_MODE, ' ', p.DATA_TYPE)
              ORDER BY p.ORDINAL_POSITION
              SEPARATOR ', '
            )
            FROM INFORMATION_SCHEMA.PARAMETERS p
            WHERE p.SPECIFIC_SCHEMA = r.ROUTINE_SCHEMA
            AND p.SPECIFIC_NAME = r.ROUTINE_NAME
            AND p.PARAMETER_NAME IS NOT NULL
          ) AS parameter_list
        FROM INFORMATION_SCHEMA.ROUTINES r
        ${schemaClause}
        AND r.ROUTINE_NAME = ?
      `,
        queryParams
      );
      if (rows.length === 0) {
        const schemaName = schema || "current schema";
        throw new Error(`Stored procedure '${procedureName}' not found in ${schemaName}`);
      }
      const procedure = rows[0];
      let definition = procedure.ROUTINE_DEFINITION;
      try {
        const schemaValue = schema || await this.getCurrentSchema();
        if (procedure.procedure_type === "procedure") {
          try {
            const [defRows] = await this.pool.query(`
              SHOW CREATE PROCEDURE ${schemaValue}.${procedureName}
            `);
            if (defRows && defRows.length > 0) {
              definition = defRows[0]["Create Procedure"];
            }
          } catch (err) {
            console.error(`Error getting procedure definition with SHOW CREATE: ${err}`);
          }
        } else {
          try {
            const [defRows] = await this.pool.query(`
              SHOW CREATE FUNCTION ${schemaValue}.${procedureName}
            `);
            if (defRows && defRows.length > 0) {
              definition = defRows[0]["Create Function"];
            }
          } catch (innerErr) {
            console.error(`Error getting function definition with SHOW CREATE: ${innerErr}`);
          }
        }
        if (!definition) {
          const [bodyRows] = await this.pool.query(
            `
            SELECT ROUTINE_DEFINITION, ROUTINE_BODY 
            FROM INFORMATION_SCHEMA.ROUTINES
            WHERE ROUTINE_SCHEMA = ? AND ROUTINE_NAME = ?
          `,
            [schemaValue, procedureName]
          );
          if (bodyRows && bodyRows.length > 0) {
            if (bodyRows[0].ROUTINE_DEFINITION) {
              definition = bodyRows[0].ROUTINE_DEFINITION;
            } else if (bodyRows[0].ROUTINE_BODY) {
              definition = bodyRows[0].ROUTINE_BODY;
            }
          }
        }
      } catch (error) {
        console.error(`Error getting procedure/function details: ${error}`);
      }
      return {
        procedure_name: procedure.procedure_name,
        procedure_type: procedure.procedure_type,
        language: "sql",
        // MySQL procedures are generally in SQL
        parameter_list: procedure.parameter_list || "",
        return_type: procedure.routine_type === "function" ? procedure.return_type : void 0,
        definition: definition || void 0
      };
    } catch (error) {
      console.error("Error getting stored procedure detail:", error);
      throw error;
    }
  }
  // Helper method to get current schema (database) name
  async getCurrentSchema() {
    const [rows] = await this.pool.query("SELECT DATABASE() AS DB");
    return rows[0].DB;
  }
  async executeSQL(sql2) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const results = await this.pool.query(sql2);
      const [firstResult] = results;
      if (Array.isArray(firstResult) && firstResult.length > 0 && Array.isArray(firstResult[0]) && firstResult[0].length === 2) {
        let allRows = [];
        for (const [rows, _fields] of firstResult) {
          if (Array.isArray(rows)) {
            allRows.push(...rows);
          }
        }
        return { rows: allRows };
      } else {
        return { rows: Array.isArray(firstResult) ? firstResult : [] };
      }
    } catch (error) {
      console.error("Error executing query:", error);
      throw error;
    }
  }
};
var mysqlConnector = new MySQLConnector();
ConnectorRegistry.register(mysqlConnector);

// src/connectors/mariadb/index.ts
import mariadb from "mariadb";
var MariadbDSNParser = class {
  async parse(dsn) {
    if (!this.isValidDSN(dsn)) {
      const obfuscatedDSN = obfuscateDSNPassword(dsn);
      const expectedFormat = this.getSampleDSN();
      throw new Error(
        `Invalid MariaDB DSN format.
Provided: ${obfuscatedDSN}
Expected: ${expectedFormat}`
      );
    }
    try {
      const url = new SafeURL(dsn);
      const config = {
        host: url.hostname,
        port: url.port ? parseInt(url.port) : 3306,
        database: url.pathname ? url.pathname.substring(1) : "",
        // Remove leading '/' if exists
        user: url.username,
        password: url.password,
        multipleStatements: true,
        // Enable native multi-statement support
        connectTimeout: 5e3
        // 5 second timeout for connections
      };
      url.forEachSearchParam((value, key) => {
        if (key === "sslmode") {
          if (value === "disable") {
            config.ssl = void 0;
          } else if (value === "require") {
            config.ssl = { rejectUnauthorized: false };
          } else {
            config.ssl = {};
          }
        }
      });
      return config;
    } catch (error) {
      throw new Error(
        `Failed to parse MariaDB DSN: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getSampleDSN() {
    return "mariadb://root:password@localhost:3306/db?sslmode=require";
  }
  isValidDSN(dsn) {
    try {
      return dsn.startsWith("mariadb://");
    } catch (error) {
      return false;
    }
  }
};
var MariaDBConnector = class {
  constructor() {
    this.id = "mariadb";
    this.name = "MariaDB";
    this.dsnParser = new MariadbDSNParser();
    this.pool = null;
  }
  async connect(dsn) {
    try {
      const config = await this.dsnParser.parse(dsn);
      this.pool = mariadb.createPool(config);
      console.error("Testing connection to MariaDB...");
      await this.pool.query("SELECT 1");
      console.error("Successfully connected to MariaDB database");
    } catch (err) {
      console.error("Failed to connect to MariaDB database:", err);
      throw err;
    }
  }
  async disconnect() {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
    }
  }
  async getSchemas() {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const rows = await this.pool.query(`
        SELECT SCHEMA_NAME 
        FROM INFORMATION_SCHEMA.SCHEMATA
        ORDER BY SCHEMA_NAME
      `);
      return rows.map((row) => row.SCHEMA_NAME);
    } catch (error) {
      console.error("Error getting schemas:", error);
      throw error;
    }
  }
  async getTables(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema] : [];
      const rows = await this.pool.query(
        `
        SELECT TABLE_NAME 
        FROM INFORMATION_SCHEMA.TABLES 
        ${schemaClause}
        ORDER BY TABLE_NAME
      `,
        queryParams
      );
      return rows.map((row) => row.TABLE_NAME);
    } catch (error) {
      console.error("Error getting tables:", error);
      throw error;
    }
  }
  async tableExists(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const rows = await this.pool.query(
        `
        SELECT COUNT(*) AS COUNT
        FROM INFORMATION_SCHEMA.TABLES 
        ${schemaClause} 
        AND TABLE_NAME = ?
      `,
        queryParams
      );
      return rows[0].COUNT > 0;
    } catch (error) {
      console.error("Error checking if table exists:", error);
      throw error;
    }
  }
  async getTableIndexes(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "TABLE_SCHEMA = ?" : "TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const indexRows = await this.pool.query(
        `
        SELECT 
          INDEX_NAME,
          COLUMN_NAME,
          NON_UNIQUE,
          SEQ_IN_INDEX
        FROM 
          INFORMATION_SCHEMA.STATISTICS 
        WHERE 
          ${schemaClause}
          AND TABLE_NAME = ? 
        ORDER BY 
          INDEX_NAME, 
          SEQ_IN_INDEX
      `,
        queryParams
      );
      const indexMap = /* @__PURE__ */ new Map();
      for (const row of indexRows) {
        const indexName = row.INDEX_NAME;
        const columnName = row.COLUMN_NAME;
        const isUnique = row.NON_UNIQUE === 0;
        const isPrimary = indexName === "PRIMARY";
        if (!indexMap.has(indexName)) {
          indexMap.set(indexName, {
            columns: [],
            is_unique: isUnique,
            is_primary: isPrimary
          });
        }
        const indexInfo = indexMap.get(indexName);
        indexInfo.columns.push(columnName);
      }
      const results = [];
      indexMap.forEach((indexInfo, indexName) => {
        results.push({
          index_name: indexName,
          column_names: indexInfo.columns,
          is_unique: indexInfo.is_unique,
          is_primary: indexInfo.is_primary
        });
      });
      return results;
    } catch (error) {
      console.error("Error getting table indexes:", error);
      throw error;
    }
  }
  async getTableSchema(tableName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE TABLE_SCHEMA = ?" : "WHERE TABLE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, tableName] : [tableName];
      const rows = await this.pool.query(
        `
        SELECT 
          COLUMN_NAME as column_name, 
          DATA_TYPE as data_type, 
          IS_NULLABLE as is_nullable,
          COLUMN_DEFAULT as column_default
        FROM INFORMATION_SCHEMA.COLUMNS
        ${schemaClause}
        AND TABLE_NAME = ?
        ORDER BY ORDINAL_POSITION
      `,
        queryParams
      );
      return rows;
    } catch (error) {
      console.error("Error getting table schema:", error);
      throw error;
    }
  }
  async getStoredProcedures(schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE ROUTINE_SCHEMA = ?" : "WHERE ROUTINE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema] : [];
      const rows = await this.pool.query(
        `
        SELECT ROUTINE_NAME
        FROM INFORMATION_SCHEMA.ROUTINES
        ${schemaClause}
        ORDER BY ROUTINE_NAME
      `,
        queryParams
      );
      return rows.map((row) => row.ROUTINE_NAME);
    } catch (error) {
      console.error("Error getting stored procedures:", error);
      throw error;
    }
  }
  async getStoredProcedureDetail(procedureName, schema) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const schemaClause = schema ? "WHERE r.ROUTINE_SCHEMA = ?" : "WHERE r.ROUTINE_SCHEMA = DATABASE()";
      const queryParams = schema ? [schema, procedureName] : [procedureName];
      const rows = await this.pool.query(
        `
        SELECT 
          r.ROUTINE_NAME AS procedure_name,
          CASE 
            WHEN r.ROUTINE_TYPE = 'PROCEDURE' THEN 'procedure'
            ELSE 'function'
          END AS procedure_type,
          LOWER(r.ROUTINE_TYPE) AS routine_type,
          r.ROUTINE_DEFINITION,
          r.DTD_IDENTIFIER AS return_type,
          (
            SELECT GROUP_CONCAT(
              CONCAT(p.PARAMETER_NAME, ' ', p.PARAMETER_MODE, ' ', p.DATA_TYPE)
              ORDER BY p.ORDINAL_POSITION
              SEPARATOR ', '
            )
            FROM INFORMATION_SCHEMA.PARAMETERS p
            WHERE p.SPECIFIC_SCHEMA = r.ROUTINE_SCHEMA
            AND p.SPECIFIC_NAME = r.ROUTINE_NAME
            AND p.PARAMETER_NAME IS NOT NULL
          ) AS parameter_list
        FROM INFORMATION_SCHEMA.ROUTINES r
        ${schemaClause}
        AND r.ROUTINE_NAME = ?
      `,
        queryParams
      );
      if (rows.length === 0) {
        const schemaName = schema || "current schema";
        throw new Error(`Stored procedure '${procedureName}' not found in ${schemaName}`);
      }
      const procedure = rows[0];
      let definition = procedure.ROUTINE_DEFINITION;
      try {
        const schemaValue = schema || await this.getCurrentSchema();
        if (procedure.procedure_type === "procedure") {
          try {
            const defRows = await this.pool.query(`
              SHOW CREATE PROCEDURE ${schemaValue}.${procedureName}
            `);
            if (defRows && defRows.length > 0) {
              definition = defRows[0]["Create Procedure"];
            }
          } catch (err) {
            console.error(`Error getting procedure definition with SHOW CREATE: ${err}`);
          }
        } else {
          try {
            const defRows = await this.pool.query(`
              SHOW CREATE FUNCTION ${schemaValue}.${procedureName}
            `);
            if (defRows && defRows.length > 0) {
              definition = defRows[0]["Create Function"];
            }
          } catch (innerErr) {
            console.error(`Error getting function definition with SHOW CREATE: ${innerErr}`);
          }
        }
        if (!definition) {
          const bodyRows = await this.pool.query(
            `
            SELECT ROUTINE_DEFINITION, ROUTINE_BODY 
            FROM INFORMATION_SCHEMA.ROUTINES
            WHERE ROUTINE_SCHEMA = ? AND ROUTINE_NAME = ?
          `,
            [schemaValue, procedureName]
          );
          if (bodyRows && bodyRows.length > 0) {
            if (bodyRows[0].ROUTINE_DEFINITION) {
              definition = bodyRows[0].ROUTINE_DEFINITION;
            } else if (bodyRows[0].ROUTINE_BODY) {
              definition = bodyRows[0].ROUTINE_BODY;
            }
          }
        }
      } catch (error) {
        console.error(`Error getting procedure/function details: ${error}`);
      }
      return {
        procedure_name: procedure.procedure_name,
        procedure_type: procedure.procedure_type,
        language: "sql",
        // MariaDB procedures are generally in SQL
        parameter_list: procedure.parameter_list || "",
        return_type: procedure.routine_type === "function" ? procedure.return_type : void 0,
        definition: definition || void 0
      };
    } catch (error) {
      console.error("Error getting stored procedure detail:", error);
      throw error;
    }
  }
  // Helper method to get current schema (database) name
  async getCurrentSchema() {
    const rows = await this.pool.query("SELECT DATABASE() AS DB");
    return rows[0].DB;
  }
  async executeSQL(sql2) {
    if (!this.pool) {
      throw new Error("Not connected to database");
    }
    try {
      const results = await this.pool.query(sql2);
      if (Array.isArray(results)) {
        if (results.length > 0 && Array.isArray(results[0]) && results[0].length > 0) {
          let allRows = [];
          for (const result of results) {
            if (Array.isArray(result)) {
              allRows.push(...result);
            }
          }
          return { rows: allRows };
        } else {
          return { rows: results };
        }
      } else {
        return { rows: [] };
      }
    } catch (error) {
      console.error("Error executing query:", error);
      throw error;
    }
  }
};
var mariadbConnector = new MariaDBConnector();
ConnectorRegistry.register(mariadbConnector);

// src/server.ts
import { McpServer as McpServer2 } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import express from "express";
import path3 from "path";
import { readFileSync } from "fs";
import { fileURLToPath as fileURLToPath3 } from "url";

// src/connectors/manager.ts
var managerInstance = null;
var ConnectorManager = class {
  constructor() {
    this.activeConnector = null;
    this.connected = false;
    if (!managerInstance) {
      managerInstance = this;
    }
  }
  /**
   * Initialize and connect to the database using a DSN
   */
  async connectWithDSN(dsn, initScript) {
    let connector = ConnectorRegistry.getConnectorForDSN(dsn);
    if (!connector) {
      throw new Error(`No connector found that can handle the DSN: ${dsn}`);
    }
    this.activeConnector = connector;
    await this.activeConnector.connect(dsn, initScript);
    this.connected = true;
  }
  /**
   * Initialize and connect to the database using a specific connector type
   */
  async connectWithType(connectorType, dsn) {
    const connector = ConnectorRegistry.getConnector(connectorType);
    if (!connector) {
      throw new Error(`Connector "${connectorType}" not found`);
    }
    this.activeConnector = connector;
    const connectionString = dsn || connector.dsnParser.getSampleDSN();
    await this.activeConnector.connect(connectionString);
    this.connected = true;
  }
  /**
   * Close the database connection
   */
  async disconnect() {
    if (this.activeConnector && this.connected) {
      await this.activeConnector.disconnect();
      this.connected = false;
    }
  }
  /**
   * Get the active connector
   */
  getConnector() {
    if (!this.activeConnector) {
      throw new Error("No active connector. Call connectWithDSN() or connectWithType() first.");
    }
    return this.activeConnector;
  }
  /**
   * Check if there's an active connection
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Get all available connector types
   */
  static getAvailableConnectors() {
    return ConnectorRegistry.getAvailableConnectors();
  }
  /**
   * Get sample DSNs for all available connectors
   */
  static getAllSampleDSNs() {
    return ConnectorRegistry.getAllSampleDSNs();
  }
  /**
   * Get the current active connector instance
   * This is used by resource and tool handlers
   */
  static getCurrentConnector() {
    if (!managerInstance) {
      throw new Error("ConnectorManager not initialized");
    }
    return managerInstance.getConnector();
  }
};

// src/config/env.ts
import dotenv from "dotenv";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
function parseCommandLineArgs() {
  const args = process.argv.slice(2);
  const parsedManually = {};
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith("--")) {
      const [key, value] = arg.substring(2).split("=");
      if (value) {
        parsedManually[key] = value;
      } else if (i + 1 < args.length && !args[i + 1].startsWith("--")) {
        parsedManually[key] = args[i + 1];
        i++;
      } else {
        parsedManually[key] = "true";
      }
    }
  }
  return parsedManually;
}
function loadEnvFiles() {
  const isDevelopment = process.env.NODE_ENV === "development" || process.argv[1]?.includes("tsx");
  const envFileNames = isDevelopment ? [".env.local", ".env"] : [".env"];
  const envPaths = [];
  for (const fileName of envFileNames) {
    envPaths.push(
      fileName,
      // Current working directory
      path.join(__dirname, "..", "..", fileName),
      // Two levels up (src/config -> src -> root)
      path.join(process.cwd(), fileName)
      // Explicit current working directory
    );
  }
  for (const envPath of envPaths) {
    console.error(`Checking for env file: ${envPath}`);
    if (fs.existsSync(envPath)) {
      dotenv.config({ path: envPath });
      return path.basename(envPath);
    }
  }
  return null;
}
function isDemoMode() {
  const args = parseCommandLineArgs();
  return args.demo === "true";
}
function isReadOnlyMode() {
  const args = parseCommandLineArgs();
  if (args.readonly !== void 0) {
    return args.readonly === "true";
  }
  if (process.env.READONLY !== void 0) {
    return process.env.READONLY === "true";
  }
  return false;
}
function resolveDSN() {
  const args = parseCommandLineArgs();
  if (isDemoMode()) {
    return {
      dsn: "sqlite:///:memory:",
      source: "demo mode",
      isDemo: true
    };
  }
  if (args.dsn) {
    return { dsn: args.dsn, source: "command line argument" };
  }
  if (process.env.DSN) {
    return { dsn: process.env.DSN, source: "environment variable" };
  }
  const loadedEnvFile = loadEnvFiles();
  if (loadedEnvFile && process.env.DSN) {
    return { dsn: process.env.DSN, source: `${loadedEnvFile} file` };
  }
  return null;
}
function resolveTransport() {
  const args = parseCommandLineArgs();
  if (args.transport) {
    const type = args.transport === "http" ? "http" : "stdio";
    return { type, source: "command line argument" };
  }
  if (process.env.TRANSPORT) {
    const type = process.env.TRANSPORT === "http" ? "http" : "stdio";
    return { type, source: "environment variable" };
  }
  return { type: "stdio", source: "default" };
}
function resolvePort() {
  const args = parseCommandLineArgs();
  if (args.port) {
    const port = parseInt(args.port, 10);
    return { port, source: "command line argument" };
  }
  if (process.env.PORT) {
    const port = parseInt(process.env.PORT, 10);
    return { port, source: "environment variable" };
  }
  return { port: 8080, source: "default" };
}
function redactDSN(dsn) {
  try {
    const url = new URL(dsn);
    if (url.password) {
      url.password = "*******";
    }
    return url.toString();
  } catch (error) {
    return dsn.replace(/\/\/([^:]+):([^@]+)@/, "//$1:***@");
  }
}

// src/config/demo-loader.ts
import fs2 from "fs";
import path2 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = path2.dirname(__filename2);
var DEMO_DATA_DIR;
var projectRootPath = path2.join(__dirname2, "..", "..", "..");
var projectResourcesPath = path2.join(projectRootPath, "resources", "employee-sqlite");
var distPath = path2.join(__dirname2, "resources", "employee-sqlite");
if (fs2.existsSync(projectResourcesPath)) {
  DEMO_DATA_DIR = projectResourcesPath;
} else if (fs2.existsSync(distPath)) {
  DEMO_DATA_DIR = distPath;
} else {
  DEMO_DATA_DIR = path2.join(process.cwd(), "resources", "employee-sqlite");
  if (!fs2.existsSync(DEMO_DATA_DIR)) {
    throw new Error(`Could not find employee-sqlite resources in any of the expected locations: 
      - ${projectResourcesPath}
      - ${distPath}
      - ${DEMO_DATA_DIR}`);
  }
}
function loadSqlFile(fileName) {
  const filePath = path2.join(DEMO_DATA_DIR, fileName);
  return fs2.readFileSync(filePath, "utf8");
}
function getSqliteInMemorySetupSql() {
  let sql2 = loadSqlFile("employee.sql");
  const readRegex = /\.read\s+([a-zA-Z0-9_]+\.sql)/g;
  let match;
  while ((match = readRegex.exec(sql2)) !== null) {
    const includePath = match[1];
    const includeContent = loadSqlFile(includePath);
    sql2 = sql2.replace(match[0], includeContent);
  }
  return sql2;
}

// src/resources/index.ts
import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";

// src/utils/response-formatter.ts
function bigIntReplacer(_key, value) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
function formatSuccessResponse(data, meta = {}) {
  return {
    success: true,
    data,
    ...Object.keys(meta).length > 0 ? { meta } : {}
  };
}
function formatErrorResponse(error, code = "ERROR", details) {
  return {
    success: false,
    error,
    code,
    ...details ? { details } : {}
  };
}
function createToolErrorResponse(error, code = "ERROR", details) {
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(formatErrorResponse(error, code, details), bigIntReplacer, 2),
        mimeType: "application/json"
      }
    ],
    isError: true
  };
}
function createToolSuccessResponse(data, meta = {}) {
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(formatSuccessResponse(data, meta), bigIntReplacer, 2),
        mimeType: "application/json"
      }
    ]
  };
}
function createResourceErrorResponse(uri, error, code = "ERROR", details) {
  return {
    contents: [
      {
        uri,
        text: JSON.stringify(formatErrorResponse(error, code, details), bigIntReplacer, 2),
        mimeType: "application/json"
      }
    ]
  };
}
function createResourceSuccessResponse(uri, data, meta = {}) {
  return {
    contents: [
      {
        uri,
        text: JSON.stringify(formatSuccessResponse(data, meta), bigIntReplacer, 2),
        mimeType: "application/json"
      }
    ]
  };
}
function formatPromptSuccessResponse(text, references = []) {
  return {
    messages: [
      {
        role: "assistant",
        content: {
          type: "text",
          text
        }
      }
    ],
    ...references.length > 0 ? { references } : {}
  };
}
function formatPromptErrorResponse(error, code = "ERROR") {
  return {
    messages: [
      {
        role: "assistant",
        content: {
          type: "text",
          text: `Error: ${error}`
        }
      }
    ],
    error,
    code
  };
}

// src/resources/tables.ts
async function tablesResourceHandler(uri, variables, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  const schemaName = variables && variables.schemaName ? Array.isArray(variables.schemaName) ? variables.schemaName[0] : variables.schemaName : void 0;
  try {
    if (schemaName) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schemaName)) {
        return createResourceErrorResponse(
          uri.href,
          `Schema '${schemaName}' does not exist or cannot be accessed`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const tableNames = await connector.getTables(schemaName);
    const responseData = {
      tables: tableNames,
      count: tableNames.length,
      schema: schemaName
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving tables: ${error.message}`,
      "TABLES_RETRIEVAL_ERROR"
    );
  }
}

// src/resources/schema.ts
async function tableStructureResourceHandler(uri, variables, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  const tableName = Array.isArray(variables.tableName) ? variables.tableName[0] : variables.tableName;
  const schemaName = variables.schemaName ? Array.isArray(variables.schemaName) ? variables.schemaName[0] : variables.schemaName : void 0;
  try {
    if (schemaName) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schemaName)) {
        return createResourceErrorResponse(
          uri.href,
          `Schema '${schemaName}' does not exist or cannot be accessed`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const tableExists = await connector.tableExists(tableName, schemaName);
    if (!tableExists) {
      const schemaInfo = schemaName ? ` in schema '${schemaName}'` : "";
      return createResourceErrorResponse(
        uri.href,
        `Table '${tableName}'${schemaInfo} does not exist or cannot be accessed`,
        "TABLE_NOT_FOUND"
      );
    }
    const columns = await connector.getTableSchema(tableName, schemaName);
    const formattedColumns = columns.map((col) => ({
      name: col.column_name,
      type: col.data_type,
      nullable: col.is_nullable === "YES",
      default: col.column_default
    }));
    const responseData = {
      table: tableName,
      schema: schemaName,
      columns: formattedColumns,
      count: formattedColumns.length
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving schema: ${error.message}`,
      "SCHEMA_RETRIEVAL_ERROR"
    );
  }
}

// src/resources/schemas.ts
async function schemasResourceHandler(uri, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  try {
    const schemas = await connector.getSchemas();
    const responseData = {
      schemas,
      count: schemas.length
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving database schemas: ${error.message}`,
      "SCHEMAS_RETRIEVAL_ERROR"
    );
  }
}

// src/resources/indexes.ts
async function indexesResourceHandler(uri, variables, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  const schemaName = variables && variables.schemaName ? Array.isArray(variables.schemaName) ? variables.schemaName[0] : variables.schemaName : void 0;
  const tableName = variables && variables.tableName ? Array.isArray(variables.tableName) ? variables.tableName[0] : variables.tableName : void 0;
  if (!tableName) {
    return createResourceErrorResponse(uri.href, "Table name is required", "MISSING_TABLE_NAME");
  }
  try {
    if (schemaName) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schemaName)) {
        return createResourceErrorResponse(
          uri.href,
          `Schema '${schemaName}' does not exist or cannot be accessed`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const tableExists = await connector.tableExists(tableName, schemaName);
    if (!tableExists) {
      return createResourceErrorResponse(
        uri.href,
        `Table '${tableName}' does not exist in schema '${schemaName || "default"}'`,
        "TABLE_NOT_FOUND"
      );
    }
    const indexes = await connector.getTableIndexes(tableName, schemaName);
    const responseData = {
      table: tableName,
      schema: schemaName,
      indexes,
      count: indexes.length
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving indexes: ${error.message}`,
      "INDEXES_RETRIEVAL_ERROR"
    );
  }
}

// src/resources/procedures.ts
async function proceduresResourceHandler(uri, variables, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  const schemaName = variables && variables.schemaName ? Array.isArray(variables.schemaName) ? variables.schemaName[0] : variables.schemaName : void 0;
  try {
    if (schemaName) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schemaName)) {
        return createResourceErrorResponse(
          uri.href,
          `Schema '${schemaName}' does not exist or cannot be accessed`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const procedureNames = await connector.getStoredProcedures(schemaName);
    const responseData = {
      procedures: procedureNames,
      count: procedureNames.length,
      schema: schemaName
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving stored procedures: ${error.message}`,
      "PROCEDURES_RETRIEVAL_ERROR"
    );
  }
}
async function procedureDetailResourceHandler(uri, variables, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  const schemaName = variables && variables.schemaName ? Array.isArray(variables.schemaName) ? variables.schemaName[0] : variables.schemaName : void 0;
  const procedureName = variables && variables.procedureName ? Array.isArray(variables.procedureName) ? variables.procedureName[0] : variables.procedureName : void 0;
  if (!procedureName) {
    return createResourceErrorResponse(uri.href, "Procedure name is required", "MISSING_PARAMETER");
  }
  try {
    if (schemaName) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schemaName)) {
        return createResourceErrorResponse(
          uri.href,
          `Schema '${schemaName}' does not exist or cannot be accessed`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const procedureDetails = await connector.getStoredProcedureDetail(procedureName, schemaName);
    const responseData = {
      procedureName: procedureDetails.procedure_name,
      procedureType: procedureDetails.procedure_type,
      language: procedureDetails.language,
      parameters: procedureDetails.parameter_list,
      returnType: procedureDetails.return_type,
      definition: procedureDetails.definition,
      schema: schemaName
    };
    return createResourceSuccessResponse(uri.href, responseData);
  } catch (error) {
    return createResourceErrorResponse(
      uri.href,
      `Error retrieving procedure details: ${error.message}`,
      "PROCEDURE_DETAILS_ERROR"
    );
  }
}

// src/resources/index.ts
function registerResources(server) {
  server.resource("schemas", "db://schemas", schemasResourceHandler);
  server.resource(
    "tables_in_schema",
    new ResourceTemplate("db://schemas/{schemaName}/tables", { list: void 0 }),
    tablesResourceHandler
  );
  server.resource(
    "table_structure_in_schema",
    new ResourceTemplate("db://schemas/{schemaName}/tables/{tableName}", { list: void 0 }),
    tableStructureResourceHandler
  );
  server.resource(
    "indexes_in_table",
    new ResourceTemplate("db://schemas/{schemaName}/tables/{tableName}/indexes", {
      list: void 0
    }),
    indexesResourceHandler
  );
  server.resource(
    "procedures_in_schema",
    new ResourceTemplate("db://schemas/{schemaName}/procedures", { list: void 0 }),
    proceduresResourceHandler
  );
  server.resource(
    "procedure_detail_in_schema",
    new ResourceTemplate("db://schemas/{schemaName}/procedures/{procedureName}", {
      list: void 0
    }),
    procedureDetailResourceHandler
  );
}

// src/tools/execute-sql.ts
import { z } from "zod";

// src/utils/allowed-keywords.ts
var allowedKeywords = {
  postgres: ["select", "with", "explain", "analyze", "show"],
  mysql: ["select", "with", "explain", "analyze", "show", "describe", "desc"],
  mariadb: ["select", "with", "explain", "analyze", "show", "describe", "desc"],
  sqlite: ["select", "with", "explain", "analyze", "pragma"],
  sqlserver: ["select", "with", "explain", "showplan"]
};

// src/tools/execute-sql.ts
var executeSqlSchema = {
  sql: z.string().describe("SQL query or multiple SQL statements to execute (separated by semicolons)")
};
function splitSQLStatements(sql2) {
  return sql2.split(";").map((statement) => statement.trim()).filter((statement) => statement.length > 0);
}
function isReadOnlySQL(sql2, connectorType) {
  const normalizedSQL = sql2.trim().toLowerCase();
  const firstWord = normalizedSQL.split(/\s+/)[0];
  const keywordList = allowedKeywords[connectorType] || allowedKeywords.default || [];
  return keywordList.includes(firstWord);
}
function areAllStatementsReadOnly(sql2, connectorType) {
  const statements = splitSQLStatements(sql2);
  return statements.every((statement) => isReadOnlySQL(statement, connectorType));
}
async function executeSqlToolHandler({ sql: sql2 }, _extra) {
  const connector = ConnectorManager.getCurrentConnector();
  try {
    if (isReadOnlyMode() && !areAllStatementsReadOnly(sql2, connector.id)) {
      return createToolErrorResponse(
        `Read-only mode is enabled. Only the following SQL operations are allowed: ${allowedKeywords[connector.id]?.join(", ") || "none"}`,
        "READONLY_VIOLATION"
      );
    }
    const result = await connector.executeSQL(sql2);
    const responseData = {
      rows: result.rows,
      count: result.rows.length
    };
    return createToolSuccessResponse(responseData);
  } catch (error) {
    return createToolErrorResponse(error.message, "EXECUTION_ERROR");
  }
}

// src/tools/index.ts
function registerTools(server) {
  server.tool(
    "execute_sql",
    "Execute a SQL query on the current database",
    executeSqlSchema,
    executeSqlToolHandler
  );
}

// src/prompts/sql-generator.ts
import { z as z2 } from "zod";
var sqlGeneratorSchema = {
  description: z2.string().describe("Natural language description of the SQL query to generate"),
  schema: z2.string().optional().describe("Optional database schema to use")
};
async function sqlGeneratorPromptHandler({
  description,
  schema
}, _extra) {
  try {
    const connector = ConnectorManager.getCurrentConnector();
    let sqlDialect;
    switch (connector.id) {
      case "postgres":
        sqlDialect = "postgres";
        break;
      case "sqlite":
        sqlDialect = "sqlite";
        break;
      case "mysql":
        sqlDialect = "mysql";
        break;
      case "sqlserver":
        sqlDialect = "mssql";
        break;
      default:
        sqlDialect = "ansi";
    }
    if (schema) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schema)) {
        return formatPromptErrorResponse(
          `Schema '${schema}' does not exist or cannot be accessed. Available schemas: ${availableSchemas.join(", ")}`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    try {
      const tables = await connector.getTables(schema);
      if (tables.length === 0) {
        const schemaInfo2 = schema ? `in schema '${schema}'` : "in the database";
        return formatPromptErrorResponse(
          `No tables found ${schemaInfo2}. Please check your database connection or schema name.`,
          "NO_TABLES_FOUND"
        );
      }
      const tableSchemas = await Promise.all(
        tables.map(async (table) => {
          try {
            const columns = await connector.getTableSchema(table, schema);
            return {
              table,
              columns: columns.map((col) => ({
                name: col.column_name,
                type: col.data_type
              }))
            };
          } catch (error) {
            return null;
          }
        })
      );
      const accessibleSchemas = tableSchemas.filter((schema2) => schema2 !== null);
      if (accessibleSchemas.length === 0) {
        return formatPromptErrorResponse(
          `No accessible tables found. You may not have sufficient permissions to access table schemas.`,
          "NO_ACCESSIBLE_TABLES"
        );
      }
      const schemaContext = accessibleSchemas.length > 0 ? `Available tables and their columns:
${accessibleSchemas.map(
        (schema2) => `- ${schema2.table}: ${schema2.columns.map((col) => `${col.name} (${col.type})`).join(", ")}`
      ).join("\n")}` : "No schema information available.";
      const dialectExamples = {
        postgres: [
          "SELECT * FROM users WHERE created_at > NOW() - INTERVAL '1 day'",
          "SELECT u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.name HAVING COUNT(o.id) > 5",
          "SELECT product_name, price FROM products WHERE price > (SELECT AVG(price) FROM products)"
        ],
        sqlite: [
          "SELECT * FROM users WHERE created_at > datetime('now', '-1 day')",
          "SELECT u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.name HAVING COUNT(o.id) > 5",
          "SELECT product_name, price FROM products WHERE price > (SELECT AVG(price) FROM products)"
        ],
        mysql: [
          "SELECT * FROM users WHERE created_at > NOW() - INTERVAL 1 DAY",
          "SELECT u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.name HAVING COUNT(o.id) > 5",
          "SELECT product_name, price FROM products WHERE price > (SELECT AVG(price) FROM products)"
        ],
        mssql: [
          "SELECT * FROM users WHERE created_at > DATEADD(day, -1, GETDATE())",
          "SELECT u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.name HAVING COUNT(o.id) > 5",
          "SELECT product_name, price FROM products WHERE price > (SELECT AVG(price) FROM products)"
        ],
        ansi: [
          "SELECT * FROM users WHERE created_at > CURRENT_TIMESTAMP - INTERVAL '1' DAY",
          "SELECT u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.name HAVING COUNT(o.id) > 5",
          "SELECT product_name, price FROM products WHERE price > (SELECT AVG(price) FROM products)"
        ]
      };
      const schemaInfo = schema ? `in schema '${schema}'` : "across all schemas";
      const prompt = `
Generate a ${sqlDialect} SQL query based on this description: "${description}"

${schemaContext}
Working ${schemaInfo}

The query should:
1. Be written for ${sqlDialect} dialect
2. Use only the available tables and columns
3. Prioritize readability
4. Include appropriate comments
5. Be compatible with ${sqlDialect} syntax
`;
      let generatedSQL;
      if (description.toLowerCase().includes("count")) {
        const schemaPrefix = schema ? `-- Schema: ${schema}
` : "";
        generatedSQL = `${schemaPrefix}-- Count query generated from: "${description}"
SELECT COUNT(*) AS count 
FROM ${accessibleSchemas.length > 0 ? accessibleSchemas[0].table : "table_name"};`;
      } else if (description.toLowerCase().includes("average") || description.toLowerCase().includes("avg")) {
        const table = accessibleSchemas.length > 0 ? accessibleSchemas[0].table : "table_name";
        const numericColumn = accessibleSchemas.length > 0 ? accessibleSchemas[0].columns.find(
          (col) => ["int", "numeric", "decimal", "float", "real", "double"].some(
            (t) => col.type.includes(t)
          )
        )?.name || "numeric_column" : "numeric_column";
        const schemaPrefix = schema ? `-- Schema: ${schema}
` : "";
        generatedSQL = `${schemaPrefix}-- Average query generated from: "${description}"
SELECT AVG(${numericColumn}) AS average
FROM ${table};`;
      } else if (description.toLowerCase().includes("join")) {
        const schemaPrefix = schema ? `-- Schema: ${schema}
` : "";
        generatedSQL = `${schemaPrefix}-- Join query generated from: "${description}"
SELECT t1.*, t2.*
FROM ${accessibleSchemas.length > 0 ? accessibleSchemas[0]?.table : "table1"} t1
JOIN ${accessibleSchemas.length > 1 ? accessibleSchemas[1]?.table : "table2"} t2
  ON t1.id = t2.${accessibleSchemas.length > 0 ? accessibleSchemas[0]?.table : "table1"}_id;`;
      } else {
        const table = accessibleSchemas.length > 0 ? accessibleSchemas[0].table : "table_name";
        const schemaPrefix = schema ? `-- Schema: ${schema}
` : "";
        generatedSQL = `${schemaPrefix}-- Query generated from: "${description}"
SELECT * 
FROM ${table}
LIMIT 10;`;
      }
      return formatPromptSuccessResponse(
        generatedSQL,
        // Add references to example queries that could help
        dialectExamples[sqlDialect]
      );
    } catch (error) {
      return formatPromptErrorResponse(
        `Error generating SQL query schema information: ${error.message}`,
        "SCHEMA_RETRIEVAL_ERROR"
      );
    }
  } catch (error) {
    return formatPromptErrorResponse(
      `Failed to generate SQL: ${error.message}`,
      "SQL_GENERATION_ERROR"
    );
  }
}

// src/prompts/db-explainer.ts
import { z as z3 } from "zod";
var dbExplainerSchema = {
  schema: z3.string().optional().describe("Optional database schema to use"),
  table: z3.string().optional().describe("Optional specific table to explain")
};
async function dbExplainerPromptHandler({
  schema,
  table
}, _extra) {
  try {
    const connector = ConnectorManager.getCurrentConnector();
    if (schema) {
      const availableSchemas = await connector.getSchemas();
      if (!availableSchemas.includes(schema)) {
        return formatPromptErrorResponse(
          `Schema '${schema}' does not exist or cannot be accessed. Available schemas: ${availableSchemas.join(", ")}`,
          "SCHEMA_NOT_FOUND"
        );
      }
    }
    const tables = await connector.getTables(schema);
    const normalizedTable = table?.toLowerCase() || "";
    const matchingTable = tables.find((t) => t.toLowerCase() === normalizedTable);
    if (matchingTable && table) {
      try {
        const columns = await connector.getTableSchema(matchingTable, schema);
        if (columns.length === 0) {
          return formatPromptErrorResponse(
            `Table '${matchingTable}' exists but has no columns or cannot be accessed.`,
            "EMPTY_TABLE_SCHEMA"
          );
        }
        const schemaInfo = schema ? ` in schema '${schema}'` : "";
        const tableDescription = `Table: ${matchingTable}${schemaInfo}
      
Structure:
${columns.map((col) => `- ${col.column_name} (${col.data_type})${col.is_nullable === "YES" ? ", nullable" : ""}${col.column_default ? `, default: ${col.column_default}` : ""}`).join("\n")}

Purpose:
This table appears to store ${determineTablePurpose(matchingTable, columns)}

Relationships:
${determineRelationships(matchingTable, columns)}`;
        return formatPromptSuccessResponse(tableDescription);
      } catch (error) {
        return formatPromptErrorResponse(
          `Error retrieving schema for table '${matchingTable}': ${error.message}`,
          "TABLE_SCHEMA_ERROR"
        );
      }
    }
    if (table && table.includes(".")) {
      const [tableName, columnName] = table.split(".");
      const tableExists = tables.find((t) => t.toLowerCase() === tableName.toLowerCase());
      if (!tableExists) {
        return formatPromptErrorResponse(
          `Table '${tableName}' does not exist in schema '${schema || "default"}'. Available tables: ${tables.slice(0, 10).join(", ")}${tables.length > 10 ? "..." : ""}`,
          "TABLE_NOT_FOUND"
        );
      }
      try {
        const columns = await connector.getTableSchema(tableName, schema);
        const column = columns.find(
          (c) => c.column_name.toLowerCase() === columnName.toLowerCase()
        );
        if (column) {
          const columnDescription = `Column: ${tableName}.${column.column_name}
          
Type: ${column.data_type}
Nullable: ${column.is_nullable === "YES" ? "Yes" : "No"}
Default: ${column.column_default || "None"}

Purpose:
${determineColumnPurpose(column.column_name, column.data_type)}`;
          return formatPromptSuccessResponse(columnDescription);
        } else {
          return formatPromptErrorResponse(
            `Column '${columnName}' does not exist in table '${tableName}'. Available columns: ${columns.map((c) => c.column_name).join(", ")}`,
            "COLUMN_NOT_FOUND"
          );
        }
      } catch (error) {
        return formatPromptErrorResponse(
          `Error accessing table schema: ${error.message}`,
          "SCHEMA_ACCESS_ERROR"
        );
      }
    }
    if (!table || ["database", "db", "schema", "overview", "all"].includes(normalizedTable)) {
      const schemaInfo = schema ? `in schema '${schema}'` : "across all schemas";
      let dbOverview = `Database Overview ${schemaInfo}

Tables: ${tables.length}
${tables.map((t) => `- ${t}`).join("\n")}

This database ${describeDatabasePurpose(tables)}`;
      return formatPromptSuccessResponse(dbOverview);
    }
    if (table && !normalizedTable.includes(".")) {
      const possibleTableMatches = tables.filter(
        (t) => t.toLowerCase().includes(normalizedTable) || normalizedTable.includes(t.toLowerCase())
      );
      if (possibleTableMatches.length > 0) {
        return formatPromptSuccessResponse(
          `Table "${table}" not found. Did you mean one of these tables?

${possibleTableMatches.join("\n")}`
        );
      } else {
        const schemaInfo = schema ? `in schema '${schema}'` : "in the database";
        return formatPromptErrorResponse(
          `Table "${table}" does not exist ${schemaInfo}. Available tables: ${tables.slice(0, 10).join(", ")}${tables.length > 10 ? "..." : ""}`,
          "TABLE_NOT_FOUND"
        );
      }
    }
  } catch (error) {
    return formatPromptErrorResponse(
      `Error explaining database: ${error.message}`,
      "EXPLANATION_ERROR"
    );
  }
  return formatPromptErrorResponse(
    `Unable to process request for schema: ${schema}, table: ${table}`,
    "UNHANDLED_REQUEST"
  );
}
function determineTablePurpose(tableName, columns) {
  const lowerTableName = tableName.toLowerCase();
  const columnNames = columns.map((c) => c.column_name.toLowerCase());
  if (lowerTableName.includes("user") || columnNames.includes("username") || columnNames.includes("email")) {
    return "user information and profiles";
  }
  if (lowerTableName.includes("order") || lowerTableName.includes("purchase")) {
    return "order or purchase transactions";
  }
  if (lowerTableName.includes("product") || lowerTableName.includes("item")) {
    return "product or item information";
  }
  if (lowerTableName.includes("log") || columnNames.includes("timestamp")) {
    return "event or activity logs";
  }
  if (columnNames.includes("created_at") && columnNames.includes("updated_at")) {
    return "tracking timestamped data records";
  }
  return "data related to " + tableName;
}
function determineRelationships(tableName, columns) {
  const potentialRelationships = [];
  const idColumns = columns.filter(
    (c) => c.column_name.toLowerCase().endsWith("_id") && !c.column_name.toLowerCase().startsWith(tableName.toLowerCase())
  );
  if (idColumns.length > 0) {
    idColumns.forEach((col) => {
      const referencedTable = col.column_name.toLowerCase().replace("_id", "");
      potentialRelationships.push(
        `May have a relationship with the "${referencedTable}" table (via ${col.column_name})`
      );
    });
  }
  if (columns.some((c) => c.column_name.toLowerCase() === "id")) {
    potentialRelationships.push(
      `May be referenced by other tables as "${tableName.toLowerCase()}_id"`
    );
  }
  return potentialRelationships.length > 0 ? potentialRelationships.join("\n") : "No obvious relationships identified based on column names";
}
function determineColumnPurpose(columnName, dataType) {
  const lowerColumnName = columnName.toLowerCase();
  if (lowerColumnName === "id") {
    return "Primary identifier for records in this table";
  }
  if (lowerColumnName.endsWith("_id")) {
    const referencedTable = lowerColumnName.replace("_id", "");
    return `Foreign key reference to the "${referencedTable}" table`;
  }
  if (lowerColumnName.includes("name")) {
    return "Stores name information";
  }
  if (lowerColumnName.includes("email")) {
    return "Stores email address information";
  }
  if (lowerColumnName.includes("password") || lowerColumnName.includes("hash")) {
    return "Stores security credential information (likely hashed)";
  }
  if (lowerColumnName === "created_at" || lowerColumnName === "created_on") {
    return "Timestamp for when the record was created";
  }
  if (lowerColumnName === "updated_at" || lowerColumnName === "modified_at") {
    return "Timestamp for when the record was last updated";
  }
  if (lowerColumnName.includes("date") || lowerColumnName.includes("time")) {
    return "Stores date or time information";
  }
  if (lowerColumnName.includes("price") || lowerColumnName.includes("cost") || lowerColumnName.includes("amount")) {
    return "Stores monetary value information";
  }
  if (dataType.includes("boolean")) {
    return "Stores a true/false flag";
  }
  if (dataType.includes("json")) {
    return "Stores structured JSON data";
  }
  if (dataType.includes("text") || dataType.includes("varchar") || dataType.includes("char")) {
    return "Stores text information";
  }
  return `Stores ${dataType} data`;
}
function describeDatabasePurpose(tables) {
  const tableNames = tables.map((t) => t.toLowerCase());
  if (tableNames.some((t) => t.includes("user")) && tableNames.some((t) => t.includes("order"))) {
    return "appears to be an e-commerce or customer order management system";
  }
  if (tableNames.some((t) => t.includes("patient")) || tableNames.some((t) => t.includes("medical"))) {
    return "appears to be related to healthcare or medical record management";
  }
  if (tableNames.some((t) => t.includes("student")) || tableNames.some((t) => t.includes("course"))) {
    return "appears to be related to education or student management";
  }
  if (tableNames.some((t) => t.includes("employee")) || tableNames.some((t) => t.includes("payroll"))) {
    return "appears to be related to HR or employee management";
  }
  if (tableNames.some((t) => t.includes("inventory")) || tableNames.some((t) => t.includes("stock"))) {
    return "appears to be related to inventory or stock management";
  }
  return "contains multiple tables that store related information";
}

// src/prompts/index.ts
function registerPrompts(server) {
  server.prompt(
    "generate_sql",
    "Generate SQL queries from natural language descriptions",
    sqlGeneratorSchema,
    sqlGeneratorPromptHandler
  );
  server.prompt(
    "explain_db",
    "Get explanations about database tables, columns, and structures",
    dbExplainerSchema,
    dbExplainerPromptHandler
  );
}

// src/server.ts
var __filename3 = fileURLToPath3(import.meta.url);
var __dirname3 = path3.dirname(__filename3);
var packageJsonPath = path3.join(__dirname3, "..", "package.json");
var packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
var SERVER_NAME = "DBHub MCP Server";
var SERVER_VERSION = packageJson.version;
function generateBanner(version, modes = []) {
  const modeText = modes.length > 0 ? ` [${modes.join(" | ")}]` : "";
  return `
 _____  ____  _   _       _     
|  __ \\|  _ \\| | | |     | |    
| |  | | |_) | |_| |_   _| |__  
| |  | |  _ <|  _  | | | | '_ \\ 
| |__| | |_) | | | | |_| | |_) |
|_____/|____/|_| |_|\\__,_|_.__/ 
                                
v${version}${modeText} - Universal Database MCP Server
`;
}
async function main() {
  try {
    const dsnData = resolveDSN();
    if (!dsnData) {
      const samples = ConnectorRegistry.getAllSampleDSNs();
      const sampleFormats = Object.entries(samples).map(([id, dsn]) => `  - ${id}: ${dsn}`).join("\n");
      console.error(`
ERROR: Database connection string (DSN) is required.
Please provide the DSN in one of these ways (in order of priority):

1. Use demo mode: --demo (uses in-memory SQLite with sample employee database)
2. Command line argument: --dsn="your-connection-string"
3. Environment variable: export DSN="your-connection-string"
4. .env file: DSN=your-connection-string

Example formats:
${sampleFormats}

See documentation for more details on configuring database connections.
`);
      process.exit(1);
    }
    const createServer = () => {
      const server = new McpServer2({
        name: SERVER_NAME,
        version: SERVER_VERSION
      });
      registerResources(server);
      registerTools(server);
      registerPrompts(server);
      return server;
    };
    const connectorManager = new ConnectorManager();
    console.error(`Connecting with DSN: ${redactDSN(dsnData.dsn)}`);
    console.error(`DSN source: ${dsnData.source}`);
    if (dsnData.isDemo) {
      const initScript = getSqliteInMemorySetupSql();
      await connectorManager.connectWithDSN(dsnData.dsn, initScript);
    } else {
      await connectorManager.connectWithDSN(dsnData.dsn);
    }
    const transportData = resolveTransport();
    console.error(`Using transport: ${transportData.type}`);
    console.error(`Transport source: ${transportData.source}`);
    const readonly = isReadOnlyMode();
    const activeModes = [];
    const modeDescriptions = [];
    if (dsnData.isDemo) {
      activeModes.push("DEMO");
      modeDescriptions.push("using sample employee database");
    }
    if (readonly) {
      activeModes.push("READ-ONLY");
      modeDescriptions.push("only read only queries allowed");
    }
    if (activeModes.length > 0) {
      console.error(`Running in ${activeModes.join(" and ")} mode - ${modeDescriptions.join(", ")}`);
    }
    console.error(generateBanner(SERVER_VERSION, activeModes));
    if (transportData.type === "http") {
      const app = express();
      app.use(express.json());
      app.use((req, res, next) => {
        const origin = req.headers.origin;
        if (origin && !origin.startsWith("http://localhost") && !origin.startsWith("https://localhost")) {
          return res.status(403).json({ error: "Forbidden origin" });
        }
        res.header("Access-Control-Allow-Origin", origin || "http://localhost");
        res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        res.header("Access-Control-Allow-Headers", "Content-Type, Mcp-Session-Id");
        res.header("Access-Control-Allow-Credentials", "true");
        if (req.method === "OPTIONS") {
          return res.sendStatus(200);
        }
        next();
      });
      app.post("/message", async (req, res) => {
        try {
          const transport = new StreamableHTTPServerTransport({
            sessionIdGenerator: void 0,
            // Disable session management for stateless mode
            enableJsonResponse: false
            // Use SSE streaming
          });
          const server = createServer();
          await server.connect(transport);
          await transport.handleRequest(req, res, req.body);
        } catch (error) {
          console.error("Error handling request:", error);
          if (!res.headersSent) {
            res.status(500).json({ error: "Internal server error" });
          }
        }
      });
      const portData = resolvePort();
      const port = portData.port;
      console.error(`Port source: ${portData.source}`);
      app.listen(port, "0.0.0.0", () => {
        console.error(`DBHub server listening at http://0.0.0.0:${port}`);
        console.error(`Connect to MCP server at http://0.0.0.0:${port}/message`);
      });
    } else {
      const server = createServer();
      const transport = new StdioServerTransport();
      console.error("Starting with STDIO transport");
      await server.connect(transport);
      process.on("SIGINT", async () => {
        console.error("Shutting down...");
        await transport.close();
        process.exit(0);
      });
    }
  } catch (err) {
    console.error("Fatal error:", err);
    process.exit(1);
  }
}

// src/index.ts
main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
